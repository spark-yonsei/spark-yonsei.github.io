I"Ì<p>Serial Communication Protocolì—ëŠ” UART, I2C, SPIê°€ ìˆë‹¤.<br />
ìµœê·¼ì—ëŠ” I2Cë¥¼ ê°œì„ í•œ I3Cê°€ ë„ì…ë˜ê³  ìˆë‹¤.<br />
<br />
<br />
UART (Universal Asynchronous Receiver-Transmitter):<br />
UARTëŠ” deviceê°„ ë‹¨ê±°ë¦¬ í†µì‹ ì— ì“°ì´ëŠ” asynchronous serial communication protocolì´ë‹¤.<br />
<br />
UART í†µì‹ ì€ ì „ì„  2ê°œë¥¼ ì‚¬ìš©í•œë‹¤.<br />
í•˜ë‚˜ëŠ” ë°ì´í„° ì†¡ì‹ ìš©(Tx), í•˜ë‚˜ëŠ” ë°ì´í„° ìˆ˜ì‹ ìš©(Rx)ì´ë‹¤.<br />
<br />
UART í†µì‹ ì€ clock ì‹ í˜¸ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.<br />
ê·¸ë˜ì„œ ê° data frame ì•ë’¤ë¡œ start bit, stop bitê°€ ìˆì–´ì•¼ í•œë‹¤.<br />
<br />
UARTëŠ” êµ¬ì¡°ê°€ ê°„ë‹¨í•œ í†µì‹  ë°©ì‹ì´ë‹¤.<br />
GPS, ë¸”ë£¨íˆ¬ìŠ¤ ë“±ì— ì“°ì¸ë‹¤.<br />
<br />
<br />
SPI (Serial Peripheral Interface):<br />
<br />
SPIëŠ” ì „ì„  4ê°œë¥¼ ì‚¬ìš©í•œë‹¤.<br />
MOSI (Master Out Slave In): Data ì†¡ì‹ <br />
MISO (Master In Slave Out): Data ìˆ˜ì‹ <br />
SCLK (Serial Clock): Clock ì‹ í˜¸<br />
CS (Chip Select): ëŒ€ìƒ device ì„ íƒ<br />
<br />
SPI í†µì‹ ì€ master-slave êµ¬ì¡°ë¡œ ì§„í–‰ëœë‹¤.<br />
masterê°€ í†µì‹ ì„ ì‹œì‘í•´ì„œ, 1ê°œ ë˜ëŠ” ì—¬ëŸ¬ê°œ slaveë¡œ ë°ì´í„°ë¥¼ ì „ì†¡í•œë‹¤.<br />
<br />
Full-duplex í†µì‹ ì„ ì§€ì›í•œë‹¤. ë°ì´í„°ë¥¼ ì „ì†¡í•˜ë©´ì„œ ë™ì‹œì— ë°ì´í„°ë¥¼ ë°›ì„ ìˆ˜ ìˆë‹¤ëŠ” ëœ»ì´ë‹¤.<br />
<br />
SPIëŠ” ë°ì´í„° ì „ì†¡ rateê°€ ë†’ì•„ì„œ,<br />
ë¹ ë¥´ê³  íš¨ìœ¨ì ì¸ ë°ì´í„° ì „ì†¡ì´ í•„ìš”í•œ ê³³ì— ì“°ì¸ë‹¤.<br />
<br />
<br />
I2C (Inter-Integrated Circuit):<br />
<br />
I2CëŠ” multi-master, multi-slave, bidirectionalì´ë‹¤.<br />
<br />
2ê°œ ì „ì„ ì„ ì“´ë‹¤.<br />
SDA (Serial Data Line): ì–‘ë°©í–¥ ë°ì´í„° ì†¡ìˆ˜ì‹ <br />
SCL (Serial Clock Line): Clock ì‹ í˜¸<br />
<br />
I2Cë¥¼ ì“°ë©´, ì„œë¡œ ë‹¤ë¥¸ addressë¥¼ ì“°ëŠ” ì—¬ëŸ¬ê°œ deviceê°€ 1ê°œ busì— ì—°ê²°ë  ìˆ˜ ìˆë‹¤.<br />
<br />
I2CëŠ” SPI, UARTë³´ë‹¤ ëŠë¦¬ì§€ë§Œ ë” ê°„ë‹¨í•œ êµ¬ì¡°ê³  ì „ì„ ë„ ëœ ì“´ë‹¤.<br />
ê·¸ë˜ì„œ pinì´ ì ì–´ì•¼ í•˜ëŠ” ì„¼ì„œ, EEPROM ë©”ëª¨ë¦¬ì¹©, real-time clock ë“±ì— ì“°ì¸ë‹¤.<br />
<br />
<br /></p>

<p>I2C</p>

<p>SDA: busë¥¼ í†µí•´ data ì „ë‹¬
SCL: master, slave ì‚¬ì´ data transferë¥¼ synchronizeí•œë‹¤.</p>

<p>I2Cê°€ ìœ„ 2ê°œë³´ë‹¤ ë‚˜ì€ ì :
Flexibility â€“ The I2C protocol supports multi-master, multi-slave communication, which implies you can add a lot of functionality to your design. More than one master IC controlling and communicating with the slave ICs can speed things up and add functionalities to the embedded system.</p>

<p>Addressing feature â€“ Yet another advantage of the I2C protocol lies in its inherent ability to use chip addressing. It means that you can easily add components to the bus without any complexity. It eliminates the necessity of CS (chip select) lines.</p>

<p>Simplicity â€“ I2C protocol doesnâ€™t complicate the design. It requires only two bidirectional signal lines to establish communication among multiple devices. Further, the pin count is low as well.</p>

<p>Better error handling mechanism â€“ To improve the error detection and correction mechanism, the I2C protocol relies on ACK/NACK feature, which is a robust error correction feature. ACK stands for Acknowledgement whereas NACK means No Acknowledgement.</p>

<p>Adaptable â€“ The I2C protocol is adaptable in the sense that it can work well with both slow ICs and fast ICs.</p>

<p>I2Cê°€ ìœ„ 2ê°œë³´ë‹¤ ì•ˆì¢‹ì€ì :
Conflicts â€“ Due to chip addressing, thereâ€™s always a possibility of an address conflict.</p>

<p>Slower speeds â€“ I2C protocol uses pull-up resistors rather than the push-pull ones used by its peers. Due to the open-drain design, the speed is limited.</p>

<p>Requires more space â€“ Now, as an embedded system engineer, you know how valuable PCB real estate is. So, it isnâ€™t such a positive attribute that the I2C protocol requires so much space for its pull-up resistors.</p>

<p>slaveëŠ” masterì—ê²Œ ACKì„ ë³´ë‚´ì•¼ í•œë‹¤.
ê·¸ë˜ì„œ ì‹ í˜¸ ë°›ê¸°ë§Œ í• ê±°ì—¬ë„ SDAëŠ” ì¶œë ¥ì„ ë³´ë‚¼ ìˆ˜ ìˆëŠ” êµ¬ì¡°ì—¬ì•¼ í•œë‹¤.</p>

<p>I2C í†µì‹ ìœ¼ë¡œ íŠ¹ì • code patternì„ ë„£ì–´ì•¼ íŠ¹ì • ë ˆì§€ìŠ¤í„°ë“¤ì— ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ í•˜ëŠ”ê²Œ protection ê¸°ëŠ¥ì´ë‹¤.
ì˜ˆë¥¼ ë“¤ì–´, analog trimming data ì˜ì—­ì€ ì‚¬ìš©ìê°€ ëª»ê±´ë“œë¦¬ê²Œ protectionì„ ê±¸ì–´ë†“ëŠ”ë‹¤. ì´ê±° ê±´ë“œë¦¬ë©´ ë™ì‘ì´ ì•„ì˜ˆ ì•ˆë ìˆ˜ë„ ìˆë‹¤.</p>

<p>I3C: Improved Inter-Integrated Circuit</p>

<p>I2C operates in five main modes:</p>

<p>Standard Mode: 100 kHz
Fast Mode: 400 kHz
Fast Mode Plus: 1 MHz
High Speed: 3.4 MHz
Ultra-Fast Mode: 5 MHz
I3C, on the other hand, has a Standard Data Rate of 12.5 MHz, with new versions of I3C supporting data rates up to 100 Mbps. Needless to say, I3C supports speeds that far surpasses that of I2C.</p>

<p>Backward Compatibility
When developing I3C, the ability for the protocol to be fully backward compatible was a significant focus. I3C applications can operate with I2C slave devices as well as native I3C devices. This backward compatibility allows engineers time to phase out their existing I2C applications. This phase-out time is necessary for embedded systems engineers because it makes the adoption of the new protocol much easier and streamlined.</p>

<p>Dynamic Addressing
I2C has a device addressing technique called static addressing. This, in simple terms, means that manufacturers lock in their device addresses in production. One of the drawbacks of this is that vendors may use the same address as another vendor for a product that uses I2C, causing issues during integration. During bus initialization, the I3C controller assigns a 7-bit dynamic address to each device on the I3C bus, thereby eliminating the problems associated with duplicate addresses because each I3C device receives a unique address from the master.</p>

<p>Hot-Join
Another new feature to I3C is the protocolâ€™s ability to allow other slave devices to be added or taken away from the system with no interrupts to the system as a whole. The system is called hot-join. This mechanism allows slaves to join the bus after the bus is already configured.</p>

<p>In-band Interrupt
The I3C interface uses a push-pull clock line and an open-drain data line for operations. The data line allows slaves to take control and initiate interrupts when needed. This feature is unique to I3C as this same application on the I2C bus would require a third line. I3C slaves can request an interrupt when the bus is idle, whereas I2C slaves cannot. I3C assesses conflicts between multiple slaves by allowing the lowest assigned address to win.</p>

<p>Power Efficiency
Another attribute important to any new technology is its ability to manage power consumption better than previous product iterations. Computers need to be faster but use much less energy than the prior model; new iterations of bus protocols are no different.</p>

<p>Due to a change in output method from an open drain method to a push-pull output, I3C can be much more energy efficient than I2C. An open-drain process requires pull-up resistors that, when activated, require a significant amount of power to operate. Push-pull operations do not require pull-up resistors to work, meaning the method can reduce energy consumption because it does not need to power any external resistors to function.</p>

<p>Another factor that plays into the power-saving quality of I3C over I2C is its data transfer speed improvements. The benefits here are simple to understand. Because messages can now be sent over the I3C bus at significantly faster rates, the bus can turn on and shut off target devices much quicker than was possible with I2C. This process saves a noticeable amount of power consumption compared to I2C.</p>
:ET