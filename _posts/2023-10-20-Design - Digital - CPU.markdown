---
layout: post
title:  "Digital - CPU"
date:   2023-10-04 19:31:29 +0900
categories: Design
order: 5
---

CPU: Central Processing Unit<br>




ISA: Instruction Set Architecture<br>
<br>
ISA는 CPU에서 사용되는 명령어들의 집합을 말한다.<br>
정상적인 CPU 동작을 위해서는 그 CPU에 맞는 ISA를 사용해야 한다.<br>
<br>
ISA는 크게 RISC 계열과 CISC 계열이 있다.<br>
ARM CPU는 RISC, x86-64 CPU는 CISC 계열 ISA를 사용한다.<br>
<br>
RISC ISA는 명령어 수를 최소화하고, 명령어 크기를 고정한 ISA다.<br>
각 명령어들의 동작을 최적화해 효율을 높인다.<br>
<br>
CISC ISA는 여러 명령어들을 묶은 복합 명령어를 많이 갖고 있는 ISA다.<br>
그래서 한 개 명령어로 구현할 수 있는 동작이 많다.<br>
<br>
<br>
RISC CPU
명령어 수 적음
명령어 크기 고정
1개 명령어 처리속도 빠름
프로그래밍 코드 복잡


CISC CPU
명령어 수 많음
명령어 크기 명령어마다 다름
1개 명령어 처리속도 명령어마다 다름
프로그래밍코드 단순



왜 cisc는 명령어마다 길이가 다르냐?
여러 명령들을 묶어서 만든 복합 명령들이 많아서 그렇다

Risc는 명령 크기를 16비트, 32비트 이런식으로 고정해둔다

처리 속도:
Risc는 명령어마다 1클럭 또는 2클럭 안에 끝내게 되어 있다
Cisc는 명령어마다 다르다. 복합 명령들이 읶으니까

프로그래밍 편의:
Cisc에서 모든 명령을 다 숙지하고 있다면, 딱 적합한 명령어를 써서 프로그래밍을 단순하게 할 수 있다

근데 그렇게 되는거 자체거 힘든 일이라, 꼭 cisc가 risc보다 프로그래밍이 쉽다고는 할 수 없다



Intel SGX, AMD TrustZone:

CPU: 명령어를 수행하는 역할
OS: 어떤 시스템이 언제 수행될지 순서, 스케줄링을 해주는 역할

그래서, 사실 CPU는 OS가 없어도 동작할 수 있다.
명령어랑 메모리만 주어지면 동작한다.

OS로부터 분리된 Enclave라는 곳에 메모리, 명령어를 넣어두면
OS가 해킹당해도 CPU가 Enclave에 적힌대로 동작할 수 있다.


데이터는 SSD에 저장되지만, SSD는 CPU에 비해 너무 느리다.
그래서 데이터를 RAM에 담아두고, CPU는 RAM과 소통한다.

컴퓨터 내 메모리는 SSD, RAM, Cache, Register가 있다.
오른쪽으로 갈수록 빠르고, 비싸고, 용량이 작다.

Register는 CPU 내에서 데이터를 잠깐 저장하는 장치다. 얘가 제일 빠르다.

Cache메모리에는 L1 L2 L3이 있다 (Level의 L)
L1이 제일 빠르고 용량이 작다.

CPU는 필요한 데이터를 L1 L2 L3 RAM 순으로 찾는다
속도가 빠른 메모리부터 찾아보는 순서다

CPU가 메모리에서 데이터를 읽어올 때,
16비트면 메모리에서 한번에 16비트, 32비트면 한번에 32비트 데이터를 읽어온다.

CPU의 각 process를 thread라 부른다.
속도를 높이고 싶다면 core 하나에서 여러개 thread를 실행시키면 될 것이다.
가능하다면, core 수를 늘려도 CPU 속도가 빨라질 것이다.


ARM의 ISA는 수천개 명령 또는 규칙으로 이루어져 있지만, 40억개 인코딩을 지원할 수 있다.
32비트 머신이면 2^32=약40억


칩은 대부분 시간동안 명령어의 20%만 사용한다
그러니 자주 쓰이는 명령어에 집중하자는게 RISC다

RISC는 모든것을 간단한 명령으로 쪼개기 때문에, 빠르고 전력을 덜 소모한다

CISC는 복잡한 명령을 처리하느라 시간이 더 걸리고 전력도 더 먹는다

대표적은 RISC 아키텍처: ARM, MIPS, SPARC


에이콘 컴퓨터는 6502로 돈벌다가, 판매가 부진해지자 먹거리를 찾다가 RISC 구조를 시도해보게 됐다
당시에는 명령어 수만 계속 늘어나고 있어서 이게 더 빠를 수 있지 않을까 싶었던거다

Reference model: 아키텍처를 간단하게 표현, 설명하기 위해, 특히 시스템 요소 간 상호관계에 대한 분석 및 이해를 용이하게 하기 위해 설계된 모델

CRISP: C언어 축소명령어 세트 프로세서

Code density:
특정한 과제를 수행하는데에 필요한 모든 명령어의 전체 크기

옛날에는 프로그램 메모리가 고가였기 때문에, 프로그래머들은 한정된 메모리 안에 프로그램을 넣기 위해 노력했다. 즉, code density를 줄이려고 노력했다

그래서 code density는 명령어 세트를 평가하는데에 있어 중요한 항목이었다

바이트 효율, 코드 효율이라고도 부른다

RISC는 과제를 소규모 단순 명령들로 세분해서 성능을 향상시킨다. 하지만 CISC에 비해 메모리를 더 쓴다

CISC는 명령어가 다양하지만 RISC는 명령어 종류가 많지 않아 코드가 길어진다

그래서 CISC 대신 RISC칩을 쓰려고 하니 메모리가 더 필요했고, 결국 더 비싸지는 문제가 있었다

32비트 아키텍처 안에, 자주 쓰이는 명령어를 수행하는 16비트 명령어 세트를 추가했다

이렇게 하먼 기존 방식보다 코드가 줄고 메모리 문제가 해결됐다



CPU: 명령어를 실행하는 역할
OS: 여러 프로그램들이 언제 실행될지 순서, 스케쥴링을 해주는 역할

그래서 CPU는 OS가 없어도, 명령어랑 메모리 공간만 주어지면 동작할 수 있다.

Enclave라는, OS로부터 분리된 곳에 메모리, 명령어를 넣어두면
OS가 해킹당해도 CPU가 enclave에 적힌대로 동작할 수 있다.
Intel: SGX(Software Guard Extensions)
AMD: TrustZone

SSD는 CPU에 비해 너무 느리기 때문에, CPU는 SSD와는 소통하지 않는다. RAM과 소통한다.

RAM도 CPU에 비하면 훨씬 느려서, 정보를 CPU 내 캐시메모리에 저장해놓고 쓴다.

캐시메모리에는 L1, L2, L3이 있다.
L1은 용량이 작고 속도가 빠르며, L3는 용량이 크고 속도가 느리다.

CPU는 속도가 빠른 메모리부터 접근을 시도한다. L1 L2 L3 RAM 순서

컴퓨터 내 메모리에는 SSD(하드디스크), RAM, Cache, Register가 있다.
Register는 CPU 내에 데이터를 잠깐 저장하는 장치다. 얘가 제일 빠르다.
SSD RAM Cache Register: 빠를수록 비싸고 용량도 작다.

레지스터는 각자 역할이 있다.
메모리 주소 레지스터, 메모리 버퍼 레지스터, 명령어 레지스터 등

CPU에서 말하는 비트 수는 한번에 읽어오는 데이터 크기를 말한다.
16비트 CPU는 메모리에서 데이터를 읽어올때 한번에 16비트씩 읽어온다.

CPU의 각 process를 thread라고 부른다.
core 하나에서 여러개 thread가 실행되면 속도가 빨라진다.
core 갯수를 늘려도 속도가 빨라진다.

프로세서 구조 = 아키텍처