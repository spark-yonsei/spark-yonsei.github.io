<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-04-12T01:37:29+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Seil Park</title><subtitle></subtitle><entry><title type="html">Analog - 2-Transistor Voltage Reference</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-2-Transistor-Voltage-Reference.html" rel="alternate" type="text/html" title="Analog - 2-Transistor Voltage Reference" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%202-Transistor%20Voltage%20Reference</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-2-Transistor-Voltage-Reference.html"><![CDATA[<p>신기하게도 MOSFET 2개만으로 만들 수 있는 Voltage Reference다.<br />
아무 MOSFET으로나 되는건 아니고, 하나는 Enhancement MOSFET, 하나는 Native 또는 Depletion MOSFET이 필요하다.<br />
<br />
2TR BGR 관련 특허들은 일본의 배터리 protection 회로 관련 회사들이 많이 냈다.<br />
<br />
Native 또는 Depletion MOSFET을 쓰면 공정시 layer가 하나 더 필요하다.<br />
Body가 무조건 ground에 연결되어야 하기 때문이다.<br />
<br />
두가지 구조가 있다.<br />
첫번째 구조부터 보면:<br />
<br /></p>
<div>
    <img src="/public/img/2tr1.png" style="width: 15%; height: auto;" alt="my picture" />
</div>
<p><br />
<br />
위쪽은 native TR이라, \(V_{th}\)가 0보다 약간 작다.<br />
그래서 M1은 항상 켜져있다.  \(V_{GS1}\)=0인데 \(V_{th1}\)는 0보다 약간 작으니까.<br />
<br />
<br />
그리고 2개 트랜지스터에 흐르는 전류는 동일하니까:<br />
\(I_{1}=\dfrac{1}{2} \mu_{n} C_{ox} \dfrac{W_1}{L_1} \left(-V_{th1} \right)^{2}\)<br />
<br />
\(I_{2}=\dfrac{1}{2} \mu_{n} C_{ox} \dfrac{W_2}{L_2} \left(V_{GS2}-V_{th2} \right)^{2}\)<br />
<br />
여기서 \(I_{1}=I_{2}\)으로 놓고 정리하면:<br />
\(V_{out} = V_{GS2} = V_{th2} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot V_{th1}\)<br />
<br />
우변은 다 트랜지스터 구조에 의해 결정되는 값들이라, 이 구조에서 \(V_{GS2}\)도 하나의 값으로 정해지게 된다.<br />
<br />
여기까지는 좋은데, 우린 이걸 BGR로 쓰고싶은거니까 온도가 변해도 전압이 일정하다는걸 확인해야 한다.<br />
온도가 변하면 \(V_{th1}, V_{th2}\)이 변한다.<br />
<br />
\(\dfrac{\partial V_{out}}{\partial T} = \dfrac{\partial V_{th2}}{\partial T} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot \dfrac{\partial V_{th1}}{\partial T}\)<br />
<br />
이 회로가 Voltage Reference로 동작하려면, \(\dfrac{\partial V_{out}}{\partial T}=0\)이 되어야 한다.<br />
즉, \(\dfrac{\partial V_{th2}}{\partial T} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot \dfrac{\partial V_{th1}}{\partial T}=0\)이 0이 되도록 트랜지스터 크기 \(\left(W_{1}, W_{2}, L_{1}, L_{2}\right)\)를 잘 조절해주면 된다.<br />
<br />
잘 조절하면 \(\dfrac{\partial V_{out}}{\partial T}=0\)이 된다.<br />
이렇게 만들면 된다.<br />
<br />
<br />
<br />
<br />
<br />
두번째 구조:<br />
<br /></p>
<div>
    <img src="/public/img/2tr2.png" style="width: 20%; height: auto;" alt="my picture" />
</div>
<p><br /></p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[신기하게도 MOSFET 2개만으로 만들 수 있는 Voltage Reference다. 아무 MOSFET으로나 되는건 아니고, 하나는 Enhancement MOSFET, 하나는 Native 또는 Depletion MOSFET이 필요하다. 2TR BGR 관련 특허들은 일본의 배터리 protection 회로 관련 회사들이 많이 냈다. Native 또는 Depletion MOSFET을 쓰면 공정시 layer가 하나 더 필요하다. Body가 무조건 ground에 연결되어야 하기 때문이다. 두가지 구조가 있다. 첫번째 구조부터 보면: 위쪽은 native TR이라, \(V_{th}\)가 0보다 약간 작다. 그래서 M1은 항상 켜져있다. \(V_{GS1}\)=0인데 \(V_{th1}\)는 0보다 약간 작으니까. 그리고 2개 트랜지스터에 흐르는 전류는 동일하니까: \(I_{1}=\dfrac{1}{2} \mu_{n} C_{ox} \dfrac{W_1}{L_1} \left(-V_{th1} \right)^{2}\) \(I_{2}=\dfrac{1}{2} \mu_{n} C_{ox} \dfrac{W_2}{L_2} \left(V_{GS2}-V_{th2} \right)^{2}\) 여기서 \(I_{1}=I_{2}\)으로 놓고 정리하면: \(V_{out} = V_{GS2} = V_{th2} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot V_{th1}\) 우변은 다 트랜지스터 구조에 의해 결정되는 값들이라, 이 구조에서 \(V_{GS2}\)도 하나의 값으로 정해지게 된다. 여기까지는 좋은데, 우린 이걸 BGR로 쓰고싶은거니까 온도가 변해도 전압이 일정하다는걸 확인해야 한다. 온도가 변하면 \(V_{th1}, V_{th2}\)이 변한다. \(\dfrac{\partial V_{out}}{\partial T} = \dfrac{\partial V_{th2}}{\partial T} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot \dfrac{\partial V_{th1}}{\partial T}\) 이 회로가 Voltage Reference로 동작하려면, \(\dfrac{\partial V_{out}}{\partial T}=0\)이 되어야 한다. 즉, \(\dfrac{\partial V_{th2}}{\partial T} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot \dfrac{\partial V_{th1}}{\partial T}=0\)이 0이 되도록 트랜지스터 크기 \(\left(W_{1}, W_{2}, L_{1}, L_{2}\right)\)를 잘 조절해주면 된다. 잘 조절하면 \(\dfrac{\partial V_{out}}{\partial T}=0\)이 된다. 이렇게 만들면 된다. 두번째 구조:]]></summary></entry><entry><title type="html">Analog - Charge Pump</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-Charge-Pump.html" rel="alternate" type="text/html" title="Analog - Charge Pump" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20Charge%20Pump</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-Charge-Pump.html"><![CDATA[<p>Charge Pump</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[Charge Pump]]></summary></entry><entry><title type="html">Analog - Crystal Oscillator</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-Crystal-Oscillator.html" rel="alternate" type="text/html" title="Analog - Crystal Oscillator" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20Crystal%20Oscillator</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-Crystal-Oscillator.html"><![CDATA[<p>Crystal Oscillator<br />
Oscillator 종류:
Rc 발진기
크리스탈 발진기: 그냥 크리스탈
크리스탈 오실레이터: 크리스탈 뿐 아니라 오실레이터 구조 전체를 하나의 패키지에 넣어둔것
그냥 전원만 넣으면 클럭이 출력된다</p>

<p>근데, 크리스탈만 있을때 전압출력은 사인파인데
크리스탈오실레이터는 전압출력이 완전 네모네모라, pcb 설계시 간섭 노이즈, emi,emc에 주의해서 배선해야 한다</p>

<p>오실레이터 관련해서는 따로 정리</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[Crystal Oscillator Oscillator 종류: Rc 발진기 크리스탈 발진기: 그냥 크리스탈 크리스탈 오실레이터: 크리스탈 뿐 아니라 오실레이터 구조 전체를 하나의 패키지에 넣어둔것 그냥 전원만 넣으면 클럭이 출력된다]]></summary></entry><entry><title type="html">Analog - H-Bridge</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-H-Bridge.html" rel="alternate" type="text/html" title="Analog - H-Bridge" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20H-Bridge</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-H-Bridge.html"><![CDATA[<p>PLL : Phase Locked Loops<br />
<br />
<br /></p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[PLL : Phase Locked Loops]]></summary></entry><entry><title type="html">Analog - LDO - Amplifier Design</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Amplifer-Design.html" rel="alternate" type="text/html" title="Analog - LDO - Amplifier Design" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20LDO%20-%20Amplifer%20Design</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Amplifer-Design.html"><![CDATA[<p>LDO : Low Dropout Regulators<br />
<br />
PMOS를 써서 만들면 Common Source 구조가 되고,<br />
NMOS를 써서 만들면 Source Follower 구조가 된다.<br />
<br />
Low-Dropout이 중요하지 않은 경우엔느 NMOS가 Pass Device로 쓰일 수 있다.<br />
Gate와 Source 사이에 전압 차이가 필요하긴 한데, Rout이 작아서(아마 NMOS PMOS의 \(\mu\)차이 이야기)<br />
Compensation이 더 쉽다.<br />
NMOS를 쓰면 follower configuration이 된다.<br />
<br />
근데 이렇게 만들면, NMOS의 gate에 들어오는 ripple이 그대로 souce(출력 노드)로 전해진다.<br />
그래서 NMOS를 쓸거면 Amp에서 Ripple이 거의 안들어오게 해야 한다.<br />
<br /></p>

<div style="float: left">
    <img src="/public/img/LDOamp1.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br />
Low Voltage Operation이 중요할때는 PMOS를 쓴다.<br />
PMOS는 Source에서 Drain으로의 Gain이든, Gate에서 Drain으로의 gain이든 모두 \(g_m r_{ds}\)다.<br />
<br />
그래서, Power line에서 ripple이 들어올 경우, Amp에서도 같은 ripple을 출력해줘야 PMOS 전류가 안흔들린다.<br />
<br />
그래서 NMOS에 쓰이는 AMP는 power line의 ripple을 다 없애야 하고,<br />
PMOS에 쓰이는 amp는 power line의 ripple을 그대로 출력에 전달해야 한다.<br />
<br />
Ripple을 그대로 전달하는 구조:<br />
<br /></p>

<div style="float: left">
    <img src="/public/img/LDOamp2.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br />
이게 왜 ripple을 그대로 전달하는 구조인가?<br />
그건 이 모델의 small signal model을 봐야 한다.<br />
아니면 이렇게 만들어도 된다.<br /></p>

<p><br /></p>

<div style="float: left">
    <img src="/public/img/LDOamp3.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br /></p>

<p><br />
아니면 이렇게 만들어도 된다.<br /></p>

<p><br /></p>

<div style="float: left">
    <img src="/public/img/LDOamp4.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br /></p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[LDO : Low Dropout Regulators PMOS를 써서 만들면 Common Source 구조가 되고, NMOS를 써서 만들면 Source Follower 구조가 된다. Low-Dropout이 중요하지 않은 경우엔느 NMOS가 Pass Device로 쓰일 수 있다. Gate와 Source 사이에 전압 차이가 필요하긴 한데, Rout이 작아서(아마 NMOS PMOS의 \(\mu\)차이 이야기) Compensation이 더 쉽다. NMOS를 쓰면 follower configuration이 된다. 근데 이렇게 만들면, NMOS의 gate에 들어오는 ripple이 그대로 souce(출력 노드)로 전해진다. 그래서 NMOS를 쓸거면 Amp에서 Ripple이 거의 안들어오게 해야 한다.]]></summary></entry><entry><title type="html">Analog - LDO - Buffer Compensation</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Buffer-Compensation.html" rel="alternate" type="text/html" title="Analog - LDO - Buffer Compensation" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20LDO%20-%20Buffer%20Compensation</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Buffer-Compensation.html"><![CDATA[<p>LDO : Low Dropout Regulators<br />
<br />
<br />
IC가 제대로 동작하기 위해서는 흔들리지 않는 일정한 전압이 필요한 부분들이 있다.<br />
OP AMP 의 입력, MOSFET의 Gate 등 전류를 흐르게 하지 않는 노드면 BGR 회로(Bandgap Reference Circuit)으로 전압을 주면 되지만,<br />
<br />
저항, Logic Gate 등 전류를 소모하는 load가 연결된 경우에는 BGR을 쓰면 전압이 이상하게 나온다.<br />
그래서, 이때는 LDO라는 회로를 써줘야 한다.<br />
<br /></p>
<div style="float: left">
    <img src="/public/img/LDO1.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>PMOS를 써서 만들면 Common Source 구조가 되고,<br />
NMOS를 써서 만들면 Source Follower 구조가 된다.<br />
<br />
Stability:<br />
어떤 주파수로 load current를 당겨도 LDO 출력전압이 안떨어질까?<br />
안타깝게도 그렇지는 않다. frequency response가 일정하지 못하다.<br />
<br />
그럼 frequency response를 어떻게 확인할 것인가?<br />
Loop Gain을 본다.<br /></p>

<div style="float: left">
    <img src="/public/img/LDO2.png" style="width: 40%; height: auto;" alt="my picture" />
</div>

<p>LDO 만들때는:<br />
Low dropout voltage,<br />
high output current,<br />
low no-load quiescent current,<br />
small output transient undershoot<br />
이런 것들이 필요하다.<br />
<br />
LDO가 낮은 dropout voltage를 유지하면서 load current도 많이 공급해주려면, Pass device로 크기가 큰 PMOS를 써야 한다. W/L이 커야 해서.<br />
근데 크기가 큰 PMOS를 쓰면, 그 device의 C가 커진다.<br />
원래는 C_load에 의한 dominant pole만 저주파에 있었어야 했는데,<br />
PMOS의 C가 크면 저주파에 pole이 하나 더 생긴다. 결국, stability가 안좋아진다.<br />
<br />
이럴 경우, LHP zero를 하나 만들어서 phase를 보상하는 방식이 있다.<br />
C_load에 직렬로 ESR(Equivalent Series Resistor)를 붙여서 만들 수 있다.<br />
<br />
근데, 이 방식은 mismatch때문에 pole zero 위치가 움직이면 큰 문제가 생길 수도 있다.<br />
그리고 current load가 크게, 순식간에 변할 경우, Cout이 작으면 급격하게 변하는 전류가 저항에 흐를 수 있다.<br />
이럴 경우, 전압이 크게 흔들린다.<br />
<br /></p>
<div style="float: left">
    <img src="/public/img/LDO3.png" style="width: 50%; height: auto;" alt="my picture" />
</div>
<p><br />
\(p_0 = \dfrac{1}{R_{out}C_{load}}\)<br />
\(p_1 = \dfrac{1}{r_{oea}C_b}\)<br />
\(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)<br />
<br />
여기서, 사용하는 buffer의 \(C_b\)와 \(r_{ob}\)가 최대한 작은게 좋다. 그래야 \(p_1\), \(p_2\)가 모두 고주파로 날아가서 \(p_0\)밖에 안남는다.<br />
<br />
일단 이렇게 생긴 source follower를 buffer로 쓴다고 해보자.</p>

<div style="float: left">
    <img src="/public/img/LDO4.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>Source follower를 buffer로 쓰면 이런 상황이 된다.<br />
이때 \(C_b\), \(r_{ob}\)가 최대한 작은 값을 갖게 해야 한다.<br />
<br />
buffer의 small signal model을 생각해보면, \(r_{ob}=\dfrac{1}{g_{m1}}\)이 된다.<br />
따라서, \(r_{ob}\)를 줄이려면 \(g_{m1}\)를 최대한 늘려야 한다.<br />
<br />
\(g_{m1}\)을 늘리는 데에는 두가지 방법이 있다.<br />
\(I_1\)을 늘리는 방법이 있고, \(\dfrac{W_1}{L_1}\)을 늘리는 방법이 있다.<br />
<br />
근데, \(I_1\)를 늘리면 buffer가 먹는 전류가 늘어나는거라, \(I_Q\)가 늘어난다.<br />
그렇다고 \(\dfrac{W_1}{L_1}\)을 늘리면 트랜지스터 크기가 커져서 \(C_b\)가 늘어난다.<br />
<br />
그래서, 위 그림에서 사용된 simple source follower는 여기서 buffer로 사용하기에 부적합하다.<br />
<br />
<br />
source follower with negative feedback을 쓰는 방법이 있다.<br />
BJT를 feedback device로 사용해서, \(r_{ob}\)를 줄이는 구조다.<br /></p>

<div style="float: left">
    <img src="/public/img/LDO5.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>buffer 입장에서 출력 전압 노드인, \(M_p\)의 gate 전압이 증가한 경우를 생각해보면:<br />
\(M_1\)의 Vds가 증가했으니, channel length modulation에 의해 \(M_1\)의 Ids가 증가한다.<br />
근데, \(M_2\)의 Ids는 Current mirror 구조에 의해 고정되어 있다.<br />
그래서, \(M_1\)의 Ids가 증가한 만큼 \(Q_1\)의 Ib가 증가하게 된다.<br />
그러면 \(Q_1\)의 Ice는 \(\beta\)Ib만큼 증가한다.<br />
<br />
그래서, 원래 Vout이 Vx만큼 증가하면 전류가 gm1Vx만큼 증가했었는데,<br />
이제는 gm1Vx + \(\beta\)gm1Vx = (1+beta)gm1Vx만큼 증가하는 것이다.<br />
<br />
따라서 \(r_{ob}=\dfrac{1}{g_{m1}(1+\beta)}\)가 된다.<br />
이렇게 되면 rob가 확 줄어드니까, gm이 그렇게까지 안커도 된다. beta가 큰 값이니까.<br />
그래서 gm을 조금 포기하는 대신 I1을 줄여 IQ를 줄일 수 있고, W/L을 줄여 Cb를 줄일 수 있다.<br />
<br />
<br />
근데 또 문제가 있다. load current가 증가하면 unity gain frequency도 증가하는데,<br />
그러면 rob도 그에 맞춰 줄어들어줘야 한다.<br />
<br />
그렇지 않으면 unity gain frequency가 계속 증가하다가 \(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)보다 커질 수도 있다.<br />
그러면 unity gain frequency 이전에 pole이 하나 더 생기는거라, stability가 안좋아진다.<br />
<br />
그래서 이런 구조를 만들게 됐다.<br />
<br />
<br /></p>

<div style="float: left">
    <img src="/public/img/LDO6.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br />
일단, 이 buffer의 output resistance는:<br />
\(r_{ob} = \dfrac{1}{g_{m1}(1+\beta)} || \dfrac{1}{g_{m4}} = \dfrac{1}{g_{m1}(1+\beta)+g_{m4}}\)<br />
<br />
<br />
이 상태에서 \(M_p\)의 \(I_{DS}\)가 증가하면?<br />
일단 \(M_p\)의 Gate 전압이 줄어들어야 할 것이다. 그래야 \(I_{DS}\)가 증가하니까.<br />
그러면 \(M_4\)와 \(M_5\)의 \(|V_{GS}|\) 가 증가한다.<br />
그래서 \(M_4\)와 \(M_5\)의 \(I_{DS}\)가 증가하는데,<br />
<br />
\(M_4\)의 \(I_{DS}\)가 증가하면 \(g_{m4}\)가 증가하고,<br />
\(M_5\)의 \(I_{DS}\)가 증가하면 \(M_2\), \(M_3\)이 이루고 있는 current mirror에 의해 \(M_1\)에서도 전류가 증가한다. 따라서 \(g_{m1}\)이 증가한다.<br />
<br />
결국, Load Current가 증가해서 \(M_p\)의 \(I_{DS}\)가 증가하면<br />
\(g_{m4}\), \(g_{m1}\)이 증가해 \(r_{ob}\)가 작아진다.<br />
그래서 \(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)는 Load current가 있을 때에도 Unity Gain Frequency보다 높은 주파수에 있을 수 있다.<br />
<br />
<br />
참고자료: A transient-Enhanced Low-Quiescent Current Low-Dropout Regulator With Buffer Impedance Attenuation</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[LDO : Low Dropout Regulators IC가 제대로 동작하기 위해서는 흔들리지 않는 일정한 전압이 필요한 부분들이 있다. OP AMP 의 입력, MOSFET의 Gate 등 전류를 흐르게 하지 않는 노드면 BGR 회로(Bandgap Reference Circuit)으로 전압을 주면 되지만, 저항, Logic Gate 등 전류를 소모하는 load가 연결된 경우에는 BGR을 쓰면 전압이 이상하게 나온다. 그래서, 이때는 LDO라는 회로를 써줘야 한다.]]></summary></entry><entry><title type="html">Analog - LDO - Frequency Response</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Frequency-Response.html" rel="alternate" type="text/html" title="Analog - LDO - Frequency Response" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20LDO%20-%20Frequency%20Response</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Frequency-Response.html"><![CDATA[<p><br />
Stability:<br />
어떤 주파수로 load current를 당겨도 LDO 출력전압이 안떨어질까?<br />
안타깝게도 그렇지는 않다. frequency response가 일정하지 못하다.<br />
<br />
그럼 frequency response를 어떻게 확인할 것인가?<br />
Loop Gain을 본다.<br /></p>

<div style="float: left">
    <img src="/public/img/LDO2.png" style="width: 40%; height: auto;" alt="my picture" />
</div>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[Stability: 어떤 주파수로 load current를 당겨도 LDO 출력전압이 안떨어질까? 안타깝게도 그렇지는 않다. frequency response가 일정하지 못하다. 그럼 frequency response를 어떻게 확인할 것인가? Loop Gain을 본다.]]></summary></entry><entry><title type="html">Analog - LDO</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-LDO.html" rel="alternate" type="text/html" title="Analog - LDO" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20LDO</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-LDO.html"><![CDATA[<p>LDO : Low Dropout Regulators<br />
<br />
<br />
IC가 제대로 동작하기 위해서는 흔들리지 않는 일정한 전압이 필요한 부분들이 있다.<br />
OP AMP 의 입력, MOSFET의 Gate 등 전류를 흐르게 하지 않는 노드면 BGR 회로(Bandgap Reference Circuit)으로 전압을 주면 되지만,<br />
<br />
저항, Logic Gate 등 전류를 소모하는 load가 연결된 경우에는 BGR을 쓰면 전압이 이상하게 나온다.<br />
그래서, 이때는 LDO라는 회로를 써줘야 한다.<br />
<br /></p>
<div style="float: left">
    <img src="/public/img/LDO1.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>PMOS를 써서 만들면 Common Source 구조가 되고,<br />
NMOS를 써서 만들면 Source Follower 구조가 된다.<br />
<br />
Stability:<br />
어떤 주파수로 load current를 당겨도 LDO 출력전압이 안떨어질까?<br />
안타깝게도 그렇지는 않다. frequency response가 일정하지 못하다.<br />
<br />
그럼 frequency response를 어떻게 확인할 것인가?<br />
Loop Gain을 본다.<br /></p>

<div style="float: left">
    <img src="/public/img/LDO2.png" style="width: 40%; height: auto;" alt="my picture" />
</div>

<p>LDO 만들때는:<br />
Low dropout voltage,<br />
high output current,<br />
low no-load quiescent current,<br />
small output transient undershoot<br />
이런 것들이 필요하다.<br />
<br />
LDO가 낮은 dropout voltage를 유지하면서 load current도 많이 공급해주려면, Pass device로 크기가 큰 PMOS를 써야 한다. W/L이 커야 해서.<br />
근데 크기가 큰 PMOS를 쓰면, 그 device의 C가 커진다.<br />
원래는 C_load에 의한 dominant pole만 저주파에 있었어야 했는데,<br />
PMOS의 C가 크면 저주파에 pole이 하나 더 생긴다. 결국, stability가 안좋아진다.<br />
<br />
이럴 경우, LHP zero를 하나 만들어서 phase를 보상하는 방식이 있다.<br />
C_load에 직렬로 ESR(Equivalent Series Resistor)를 붙여서 만들 수 있다.<br />
<br />
근데, 이 방식은 mismatch때문에 pole zero 위치가 움직이면 큰 문제가 생길 수도 있다.<br />
그리고 current load가 크게, 순식간에 변할 경우, Cout이 작으면 급격하게 변하는 전류가 저항에 흐를 수 있다.<br />
이럴 경우, 전압이 크게 흔들린다.<br />
<br /></p>
<div style="float: left">
    <img src="/public/img/LDO3.png" style="width: 50%; height: auto;" alt="my picture" />
</div>
<p><br />
\(p_0 = \dfrac{1}{R_{out}C_{load}}\)<br />
\(p_1 = \dfrac{1}{r_{oea}C_b}\)<br />
\(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)<br />
<br />
여기서, 사용하는 buffer의 \(C_b\)와 \(r_{ob}\)가 최대한 작은게 좋다. 그래야 \(p_1\), \(p_2\)가 모두 고주파로 날아가서 \(p_0\)밖에 안남는다.<br />
<br />
일단 이렇게 생긴 source follower를 buffer로 쓴다고 해보자.</p>

<div style="float: left">
    <img src="/public/img/LDO4.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>Source follower를 buffer로 쓰면 이런 상황이 된다.<br />
이때 \(C_b\), \(r_{ob}\)가 최대한 작은 값을 갖게 해야 한다.<br />
<br />
buffer의 small signal model을 생각해보면, \(r_{ob}=\dfrac{1}{g_{m1}}\)이 된다.<br />
따라서, \(r_{ob}\)를 줄이려면 \(g_{m1}\)를 최대한 늘려야 한다.<br />
<br />
\(g_{m1}\)을 늘리는 데에는 두가지 방법이 있다.<br />
\(I_1\)을 늘리는 방법이 있고, \(\dfrac{W_1}{L_1}\)을 늘리는 방법이 있다.<br />
<br />
근데, \(I_1\)를 늘리면 buffer가 먹는 전류가 늘어나는거라, \(I_Q\)가 늘어난다.<br />
그렇다고 \(\dfrac{W_1}{L_1}\)을 늘리면 트랜지스터 크기가 커져서 \(C_b\)가 늘어난다.<br />
<br />
그래서, 위 그림에서 사용된 simple source follower는 여기서 buffer로 사용하기에 부적합하다.<br />
<br />
<br />
source follower with negative feedback을 쓰는 방법이 있다.<br />
BJT를 feedback device로 사용해서, \(r_{ob}\)를 줄이는 구조다.<br /></p>

<div style="float: left">
    <img src="/public/img/LDO5.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>buffer 입장에서 출력 전압 노드인, \(M_p\)의 gate 전압이 증가한 경우를 생각해보면:<br />
\(M_1\)의 Vds가 증가했으니, channel length modulation에 의해 \(M_1\)의 Ids가 증가한다.<br />
근데, \(M_2\)의 Ids는 Current mirror 구조에 의해 고정되어 있다.<br />
그래서, \(M_1\)의 Ids가 증가한 만큼 \(Q_1\)의 Ib가 증가하게 된다.<br />
그러면 \(Q_1\)의 Ice는 \(\beta\)Ib만큼 증가한다.<br />
<br />
그래서, 원래 Vout이 Vx만큼 증가하면 전류가 gm1Vx만큼 증가했었는데,<br />
이제는 gm1Vx + \(\beta\)gm1Vx = (1+beta)gm1Vx만큼 증가하는 것이다.<br />
<br />
따라서 \(r_{ob}=\dfrac{1}{g_{m1}(1+\beta)}\)가 된다.<br />
이렇게 되면 rob가 확 줄어드니까, gm이 그렇게까지 안커도 된다. beta가 큰 값이니까.<br />
그래서 gm을 조금 포기하는 대신 I1을 줄여 IQ를 줄일 수 있고, W/L을 줄여 Cb를 줄일 수 있다.<br />
<br />
<br />
근데 또 문제가 있다. load current가 증가하면 unity gain frequency도 증가하는데,<br />
그러면 rob도 그에 맞춰 줄어들어줘야 한다.<br />
<br />
그렇지 않으면 unity gain frequency가 계속 증가하다가 \(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)보다 커질 수도 있다.<br />
그러면 unity gain frequency 이전에 pole이 하나 더 생기는거라, stability가 안좋아진다.<br />
<br />
그래서 이런 구조를 만들게 됐다.<br />
<br />
<br /></p>

<div style="float: left">
    <img src="/public/img/LDO6.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br />
일단, 이 buffer의 output resistance는:<br />
\(r_{ob} = \dfrac{1}{g_{m1}(1+\beta)} || \dfrac{1}{g_{m4}} = \dfrac{1}{g_{m1}(1+\beta)+g_{m4}}\)<br />
<br />
<br />
이 상태에서 \(M_p\)의 \(I_{DS}\)가 증가하면?<br />
일단 \(M_p\)의 Gate 전압이 줄어들어야 할 것이다. 그래야 \(I_{DS}\)가 증가하니까.<br />
그러면 \(M_4\)와 \(M_5\)의 \(|V_{GS}|\) 가 증가한다.<br />
그래서 \(M_4\)와 \(M_5\)의 \(I_{DS}\)가 증가하는데,<br />
<br />
\(M_4\)의 \(I_{DS}\)가 증가하면 \(g_{m4}\)가 증가하고,<br />
\(M_5\)의 \(I_{DS}\)가 증가하면 \(M_2\), \(M_3\)이 이루고 있는 current mirror에 의해 \(M_1\)에서도 전류가 증가한다. 따라서 \(g_{m1}\)이 증가한다.<br />
<br />
결국, Load Current가 증가해서 \(M_p\)의 \(I_{DS}\)가 증가하면<br />
\(g_{m4}\), \(g_{m1}\)이 증가해 \(r_{ob}\)가 작아진다.<br />
그래서 \(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)는 Load current가 증가하면 더 높은 주파수로 이동하기에,
항상 Unity Gain Frequency보다 높은 주파수에 있을 수 있다.<br />
<br /></p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[LDO : Low Dropout Regulators IC가 제대로 동작하기 위해서는 흔들리지 않는 일정한 전압이 필요한 부분들이 있다. OP AMP 의 입력, MOSFET의 Gate 등 전류를 흐르게 하지 않는 노드면 BGR 회로(Bandgap Reference Circuit)으로 전압을 주면 되지만, 저항, Logic Gate 등 전류를 소모하는 load가 연결된 경우에는 BGR을 쓰면 전압이 이상하게 나온다. 그래서, 이때는 LDO라는 회로를 써줘야 한다.]]></summary></entry><entry><title type="html">Analog - PLL</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-PLL.html" rel="alternate" type="text/html" title="Analog - PLL" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20PLL</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-PLL.html"><![CDATA[<p>PLL : Phase Locked Loops<br />
<br />
<br />
원래는 주파수 높은 clock을 만들려고 쓰지만, 동작 주파수가 낮은 경우에도 clock의 jitter를 없애기 위해 PLL을 쓰기도 한다.
PLL이 Lock되면, PLL block에서 Lock 신호를 high로 올려준다.
다른 block들은 그거 보고 동작하기 시작하면 된다.</p>

<p>chip이 켜지면 Analog trimming data 등 정보가 들어있는 Flash memory를 읽는데,
Flash memory를 PLL이 Lock 되기 전에 읽기도 한다. PLL이 Lock되는 데에는 시간이 좀 걸리니까, 시간 아끼기 위해서다.</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[PLL : Phase Locked Loops 원래는 주파수 높은 clock을 만들려고 쓰지만, 동작 주파수가 낮은 경우에도 clock의 jitter를 없애기 위해 PLL을 쓰기도 한다. PLL이 Lock되면, PLL block에서 Lock 신호를 high로 올려준다. 다른 block들은 그거 보고 동작하기 시작하면 된다.]]></summary></entry><entry><title type="html">Analog - Sigma-Delta ADC</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-Sigma-Delta-ADC.html" rel="alternate" type="text/html" title="Analog - Sigma-Delta ADC" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20Sigma-Delta%20ADC</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-Sigma-Delta-ADC.html"><![CDATA[<p>adf</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[adf]]></summary></entry></feed>