<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-04-14T02:43:26+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Seil Park</title><subtitle></subtitle><entry><title type="html">Analog - 2-Transistor Voltage Reference</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-2-Transistor-Voltage-Reference.html" rel="alternate" type="text/html" title="Analog - 2-Transistor Voltage Reference" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%202-Transistor%20Voltage%20Reference</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-2-Transistor-Voltage-Reference.html"><![CDATA[<p>신기하게도 MOSFET 2개만으로 만들 수 있는 Voltage Reference다.<br />
아무 MOSFET으로나 되는건 아니고, 하나는 Enhancement MOSFET, 하나는 Native 또는 Depletion MOSFET이 필요하다.<br />
<br />
2TR BGR 관련 특허들은 일본의 배터리 protection 회로 관련 회사들이 많이 냈다.<br />
<br />
Native 또는 Depletion MOSFET을 쓰면 공정시 layer가 하나 더 필요하다.<br />
Body가 무조건 ground에 연결되어야 하기 때문이다.<br />
<br />
두가지 구조가 있다.<br />
첫번째 구조부터 보면:<br />
<br /></p>
<div>
    <img src="/public/img/2tr1.png" style="width: 15%; height: auto;" alt="my picture" />
</div>
<p><br />
<br />
위쪽은 native TR이라, \(V_{th}\)가 0보다 약간 작다.<br />
그래서 M1은 항상 켜져있다.  \(V_{GS1}\)=0인데 \(V_{th1}\)는 0보다 약간 작으니까.<br />
<br />
<br />
그리고 2개 트랜지스터에 흐르는 전류는 동일하니까:<br />
\(I_{1}=\dfrac{1}{2} \mu_{n} C_{ox} \dfrac{W_1}{L_1} \left(-V_{th1} \right)^{2}\)<br />
<br />
\(I_{2}=\dfrac{1}{2} \mu_{n} C_{ox} \dfrac{W_2}{L_2} \left(V_{GS2}-V_{th2} \right)^{2}\)<br />
<br />
여기서 \(I_{1}=I_{2}\)으로 놓고 정리하면:<br />
\(V_{out} = V_{GS2} = V_{th2} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot V_{th1}\)<br />
<br />
우변은 다 트랜지스터 구조에 의해 결정되는 값들이라, 이 구조에서 \(V_{GS2}\)도 하나의 값으로 정해지게 된다.<br />
<br />
여기까지는 좋은데, 우린 이걸 BGR로 쓰고싶은거니까 온도가 변해도 전압이 일정하다는걸 확인해야 한다.<br />
온도가 변하면 \(V_{th1}, V_{th2}\)이 변한다.<br />
<br />
\(\dfrac{\partial V_{out}}{\partial T} = \dfrac{\partial V_{th2}}{\partial T} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot \dfrac{\partial V_{th1}}{\partial T}\)<br />
<br />
이 회로가 Voltage Reference로 동작하려면, \(\dfrac{\partial V_{out}}{\partial T}=0\)이 되어야 한다.<br />
즉, \(\dfrac{\partial V_{th2}}{\partial T} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot \dfrac{\partial V_{th1}}{\partial T}=0\)이 0이 되도록 트랜지스터 크기 \(\left(W_{1}, W_{2}, L_{1}, L_{2}\right)\)를 잘 조절해주면 된다.<br />
<br />
잘 조절하면 \(\dfrac{\partial V_{out}}{\partial T}=0\)이 된다.<br />
이렇게 만들면 된다.<br />
<br />
<br />
<br />
<br />
<br />
두번째 구조:<br />
<br /></p>
<div>
    <img src="/public/img/2tr2.png" style="width: 20%; height: auto;" alt="my picture" />
</div>
<p><br /></p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[신기하게도 MOSFET 2개만으로 만들 수 있는 Voltage Reference다. 아무 MOSFET으로나 되는건 아니고, 하나는 Enhancement MOSFET, 하나는 Native 또는 Depletion MOSFET이 필요하다. 2TR BGR 관련 특허들은 일본의 배터리 protection 회로 관련 회사들이 많이 냈다. Native 또는 Depletion MOSFET을 쓰면 공정시 layer가 하나 더 필요하다. Body가 무조건 ground에 연결되어야 하기 때문이다. 두가지 구조가 있다. 첫번째 구조부터 보면: 위쪽은 native TR이라, \(V_{th}\)가 0보다 약간 작다. 그래서 M1은 항상 켜져있다. \(V_{GS1}\)=0인데 \(V_{th1}\)는 0보다 약간 작으니까. 그리고 2개 트랜지스터에 흐르는 전류는 동일하니까: \(I_{1}=\dfrac{1}{2} \mu_{n} C_{ox} \dfrac{W_1}{L_1} \left(-V_{th1} \right)^{2}\) \(I_{2}=\dfrac{1}{2} \mu_{n} C_{ox} \dfrac{W_2}{L_2} \left(V_{GS2}-V_{th2} \right)^{2}\) 여기서 \(I_{1}=I_{2}\)으로 놓고 정리하면: \(V_{out} = V_{GS2} = V_{th2} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot V_{th1}\) 우변은 다 트랜지스터 구조에 의해 결정되는 값들이라, 이 구조에서 \(V_{GS2}\)도 하나의 값으로 정해지게 된다. 여기까지는 좋은데, 우린 이걸 BGR로 쓰고싶은거니까 온도가 변해도 전압이 일정하다는걸 확인해야 한다. 온도가 변하면 \(V_{th1}, V_{th2}\)이 변한다. \(\dfrac{\partial V_{out}}{\partial T} = \dfrac{\partial V_{th2}}{\partial T} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot \dfrac{\partial V_{th1}}{\partial T}\) 이 회로가 Voltage Reference로 동작하려면, \(\dfrac{\partial V_{out}}{\partial T}=0\)이 되어야 한다. 즉, \(\dfrac{\partial V_{th2}}{\partial T} - \sqrt{\dfrac{W_1L_2}{L_1W_2}} \cdot \dfrac{\partial V_{th1}}{\partial T}=0\)이 0이 되도록 트랜지스터 크기 \(\left(W_{1}, W_{2}, L_{1}, L_{2}\right)\)를 잘 조절해주면 된다. 잘 조절하면 \(\dfrac{\partial V_{out}}{\partial T}=0\)이 된다. 이렇게 만들면 된다. 두번째 구조:]]></summary></entry><entry><title type="html">Analog - Charge Pump</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-Charge-Pump.html" rel="alternate" type="text/html" title="Analog - Charge Pump" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20Charge%20Pump</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-Charge-Pump.html"><![CDATA[<p>Charge Pump</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[Charge Pump]]></summary></entry><entry><title type="html">Analog - Crystal Oscillator</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-Crystal-Oscillator.html" rel="alternate" type="text/html" title="Analog - Crystal Oscillator" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20Crystal%20Oscillator</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-Crystal-Oscillator.html"><![CDATA[<p>Crystal Oscillator<br />
Oscillator 종류:<br />
Rc 발진기<br />
크리스탈 발진기: 그냥 크리스탈<br />
크리스탈 오실레이터: 크리스탈 뿐 아니라 오실레이터 구조 전체를 하나의 패키지에 넣어둔것<br />
그냥 전원만 넣으면 클럭이 출력된다<br />
<br />
근데, 크리스탈만 있을때 전압출력은 사인파인데<br />
크리스탈오실레이터는 전압출력이 완전 네모네모라, pcb 설계시 간섭 노이즈, emi,emc에 주의해서 배선해야 한다<br />
<br />
<br />
Crystal oscillator는:<br />
항상 켜져있어야 하는 block이라, power 소비가 적어야 한다.<br />
항상 같은 주파수를 만들어야 하기 때문에, PVT variation에 적게 영향받아야 한다.<br />
오랫동안 켜둬도 주파수가 일정해야 한다. 즉, Allan Deviation이 작아야 한다.<br />
<br />
외부에서 Crystal에 넣어줘야 하는 power:<br />
P_Extr: extract oscillation frequency and phase<br />
P_Ener: Inject energy into crystal to compensate loss<br />
P_Timi: Timing control of energy injection<br />
<br />
P_XO = P_Extr + P_Ener + P_Timi<br />
<br />
그리고 넣어주는 에너지가 소비하는 에너지보다 많아야 한다고 한다? 왜 부등호인지는 생각좀 해봐야겠다<br />
P_XO &gt; P_loss<br />
<br /></p>

<div style="float: left">
    <img src="/public/img/XO1.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br />
Crystal의 등가회로는 이렇다.<br />
쓸때는 이렇게 밑에 shunt capacitance를 붙여서 쓴다.<br />
<br /></p>

<div style="float: left">
    <img src="/public/img/XO2.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br />
당연히, 이렇게만 둔다고 동작하는건 아니다.
밖에서 에너지를 넣어줘야 진동을 할거다.
그 역할을 하는 회로를 붙여줘야 한다.</p>

<p>Resonance mode가 2개 있는데,
Parallel mode가 있고 series mode가 있다.</p>

<p>Parallel mode 진동을 할때는 inverter를 붙여주면 되고,
Series mode 진동을 할때는 buffer를 붙여주면 된다.</p>

<p>Parallel mode:
Ls가 Cs뿐 아니라 Co, Cp의 영향도 받아 진동한다.</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[Crystal Oscillator Oscillator 종류: Rc 발진기 크리스탈 발진기: 그냥 크리스탈 크리스탈 오실레이터: 크리스탈 뿐 아니라 오실레이터 구조 전체를 하나의 패키지에 넣어둔것 그냥 전원만 넣으면 클럭이 출력된다 근데, 크리스탈만 있을때 전압출력은 사인파인데 크리스탈오실레이터는 전압출력이 완전 네모네모라, pcb 설계시 간섭 노이즈, emi,emc에 주의해서 배선해야 한다 Crystal oscillator는: 항상 켜져있어야 하는 block이라, power 소비가 적어야 한다. 항상 같은 주파수를 만들어야 하기 때문에, PVT variation에 적게 영향받아야 한다. 오랫동안 켜둬도 주파수가 일정해야 한다. 즉, Allan Deviation이 작아야 한다. 외부에서 Crystal에 넣어줘야 하는 power: P_Extr: extract oscillation frequency and phase P_Ener: Inject energy into crystal to compensate loss P_Timi: Timing control of energy injection P_XO = P_Extr + P_Ener + P_Timi 그리고 넣어주는 에너지가 소비하는 에너지보다 많아야 한다고 한다? 왜 부등호인지는 생각좀 해봐야겠다 P_XO &gt; P_loss]]></summary></entry><entry><title type="html">Analog - H-Bridge</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-H-Bridge.html" rel="alternate" type="text/html" title="Analog - H-Bridge" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20H-Bridge</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-H-Bridge.html"><![CDATA[<p>H-bridge는 4개 FET을 써서 load에다가 전류를 준다.
inductive motor들이 주로 load로 쓰인다.</p>

<p>H-bridge에는 External diodes(Free-wheeling diode 또는 flyback diode라고도 불린다)가 들어가지 않을 때도 있다
FET의 body diode를 쓸 수도 있기 때문이다.</p>

<p>H-bridge에서 조심할 점:
절대 한쪽 FET 2개를 동시에 켜면 안된다. Q1 Q2를 동시에 켜거나 Q3, Q4를 동시에 켜면 안된다는거다.
이러면 전원에서 ground까지 impedance가 아주 작은 경로가 생겨버려서,
전류가 엄청나게 흐르고 FET이 damage를 입을 수도 있다.
이게 shoot through다.</p>

<p>Fast decay mode랑 slow decay mode가 있는데, 모터 속도 이야기가 아니고 모터 안 인덕터의 전류가 decaying되는 속도 이야기다.
그래서 fast decay mode를 쓴다고 모터가 빨리 멈추는게 아니다. 실제로는 slow decay mode에서 모터가 더 빨리 멈춘다.</p>

<p>예를 들어, Q1 Q4가 켜져서 motor가 돌고 있다고 해보자. 갑자기 Q1 Q4가 꺼지면?
모터의 인덕터는 전류가 연속이어야 하니까, 전류는 바로 0이 되지 않고 flyback diode 또는 FET body diode를 통해 흘러나간다.
이러면 전류가 천천히 0이 될거다.</p>

<p>여기서, Fast decay mode는 전류 빠질때 diode가 아니라 FET으로 빠지게 하는 방식이다.
Q1 Q4가 꺼지면 Q2 Q3을 켜는 식이다. 이러면 인덕터에 전압 0이 걸리는게 아니라 -Vpp가 걸려서, 전류가 더 빨리 빠져나간다.
물론, shoot through가 안일어나도록 잘 제어해줘야 한다.</p>

<p>근데 뭐 모터 멈추는데 있어서 fast decay mode가 꼭 필요한건 아니다.
fast decay mode는 high inductance motor나 high speed motor 등 전류가 빠르게 변해야 하는 곳에 쓰인다.</p>

<p>그리고, diode에 의한 전압강하보다 FET의 ron에 의한 전압강하가 더 작다면 fast decay mode가 power를 아끼는 데에도 도움이 될 수 있다.</p>

<p>아까처럼, Q1 Q4가 켜진 채로 모터가 돌고 있다고 해보자.
그냥 모터를 끄려면 Q1 Q4를 끄고,
fast decay mode로 모터를 끄려면 Q1 Q4를 끄면서 Q2 Q3을 켠다.</p>

<p>slow decay mode로 모터를 끄려면 Q1을 끄면서 Q2를 켜거나 Q4를 끄면서 Q3을 끈다.
즉, 위쪽 2개나 아래쪽 2개만 켜져있게 한다.</p>

<p>이렇게 하면, 켜져있는 2개 FET의 ron에 의해 전류가 열로 dissipate되면서 사라진다.
이 mode는 전류가 줄어드는건 fast decay mode보다 더 느린데, 모터가 멈추는건 더 빠르다.
이유는 motor의 에너지 관점에서 생각해줘야 한다.</p>

<p>DC motor가 회전할 경우, back emf가 생긴다.
fast decay mode에서는 전류는 빨리 나가는데, back emf에는 별 조치가 안돼서 motor가 느리게 멈춘다.</p>

<p>slow decay mode에서는 back emf의 양단 사이에 ron 저항 2개밖에 없다.
그래서 거의 short라서, motor에 있던 에너지가 아주 빠르게 열에너지로 바뀌어 사라진다.
즉 모터가 빠르게 멈춘다.</p>

<p>그니까, slow랑 fast는 inductive load (여기서는 motor winding)에 흐르는 전류가 줄어드는 rate를 말하는거다.
모터의 각속도 이야기가 아니다.</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[H-bridge는 4개 FET을 써서 load에다가 전류를 준다. inductive motor들이 주로 load로 쓰인다.]]></summary></entry><entry><title type="html">Analog - LDO - Amplifier Design</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Amplifer-Design.html" rel="alternate" type="text/html" title="Analog - LDO - Amplifier Design" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20LDO%20-%20Amplifer%20Design</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Amplifer-Design.html"><![CDATA[<p>LDO : Low Dropout Regulators<br />
<br />
PMOS를 써서 만들면 Common Source 구조가 되고,<br />
NMOS를 써서 만들면 Source Follower 구조가 된다.<br />
<br />
Low-Dropout이 중요하지 않은 경우엔느 NMOS가 Pass Device로 쓰일 수 있다.<br />
Gate와 Source 사이에 전압 차이가 필요하긴 한데, Rout이 작아서(아마 NMOS PMOS의 \(\mu\)차이 이야기)<br />
Compensation이 더 쉽다.<br />
NMOS를 쓰면 follower configuration이 된다.<br />
<br />
근데 이렇게 만들면, NMOS의 gate에 들어오는 ripple이 그대로 souce(출력 노드)로 전해진다.<br />
그래서 NMOS를 쓸거면 Amp에서 Ripple이 거의 안들어오게 해야 한다.<br />
<br /></p>

<div style="float: left">
    <img src="/public/img/LDOamp1.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br />
Low Voltage Operation이 중요할때는 PMOS를 쓴다.<br />
PMOS는 Source에서 Drain으로의 Gain이든, Gate에서 Drain으로의 gain이든 모두 \(g_m r_{ds}\)다.<br />
<br />
그래서, Power line에서 ripple이 들어올 경우, Amp에서도 같은 ripple을 출력해줘야 PMOS 전류가 안흔들린다.<br />
<br />
그래서 NMOS에 쓰이는 AMP는 power line의 ripple을 다 없애야 하고,<br />
PMOS에 쓰이는 amp는 power line의 ripple을 그대로 출력에 전달해야 한다.<br />
<br />
Ripple을 그대로 전달하는 구조:<br />
<br /></p>

<div style="float: left">
    <img src="/public/img/LDOamp2.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br />
이게 왜 ripple을 그대로 전달하는 구조인가?<br />
그건 이 모델의 small signal model을 봐야 한다.<br />
아니면 이렇게 만들어도 된다.<br /></p>

<p><br /></p>

<div style="float: left">
    <img src="/public/img/LDOamp3.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br /></p>

<p><br />
아니면 이렇게 만들어도 된다.<br /></p>

<p><br /></p>

<div style="float: left">
    <img src="/public/img/LDOamp4.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br /></p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[LDO : Low Dropout Regulators PMOS를 써서 만들면 Common Source 구조가 되고, NMOS를 써서 만들면 Source Follower 구조가 된다. Low-Dropout이 중요하지 않은 경우엔느 NMOS가 Pass Device로 쓰일 수 있다. Gate와 Source 사이에 전압 차이가 필요하긴 한데, Rout이 작아서(아마 NMOS PMOS의 \(\mu\)차이 이야기) Compensation이 더 쉽다. NMOS를 쓰면 follower configuration이 된다. 근데 이렇게 만들면, NMOS의 gate에 들어오는 ripple이 그대로 souce(출력 노드)로 전해진다. 그래서 NMOS를 쓸거면 Amp에서 Ripple이 거의 안들어오게 해야 한다.]]></summary></entry><entry><title type="html">Analog - LDO - Buffer Compensation</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Buffer-Compensation.html" rel="alternate" type="text/html" title="Analog - LDO - Buffer Compensation" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20LDO%20-%20Buffer%20Compensation</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Buffer-Compensation.html"><![CDATA[<p>LDO : Low Dropout Regulators<br />
<br />
<br />
IC가 제대로 동작하기 위해서는 흔들리지 않는 일정한 전압이 필요한 부분들이 있다.<br />
OP AMP 의 입력, MOSFET의 Gate 등 전류를 흐르게 하지 않는 노드면 BGR 회로(Bandgap Reference Circuit)으로 전압을 주면 되지만,<br />
<br />
저항, Logic Gate 등 전류를 소모하는 load가 연결된 경우에는 BGR을 쓰면 전압이 이상하게 나온다.<br />
그래서, 이때는 LDO라는 회로를 써줘야 한다.<br />
<br /></p>
<div style="float: left">
    <img src="/public/img/LDO1.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>PMOS를 써서 만들면 Common Source 구조가 되고,<br />
NMOS를 써서 만들면 Source Follower 구조가 된다.<br />
<br />
Stability:<br />
어떤 주파수로 load current를 당겨도 LDO 출력전압이 안떨어질까?<br />
안타깝게도 그렇지는 않다. frequency response가 일정하지 못하다.<br />
<br />
그럼 frequency response를 어떻게 확인할 것인가?<br />
Loop Gain을 본다.<br /></p>

<div style="float: left">
    <img src="/public/img/LDO2.png" style="width: 40%; height: auto;" alt="my picture" />
</div>

<p>LDO 만들때는:<br />
Low dropout voltage,<br />
high output current,<br />
low no-load quiescent current,<br />
small output transient undershoot<br />
이런 것들이 필요하다.<br />
<br />
LDO가 낮은 dropout voltage를 유지하면서 load current도 많이 공급해주려면, Pass device로 크기가 큰 PMOS를 써야 한다. W/L이 커야 해서.<br />
근데 크기가 큰 PMOS를 쓰면, 그 device의 C가 커진다.<br />
원래는 C_load에 의한 dominant pole만 저주파에 있었어야 했는데,<br />
PMOS의 C가 크면 저주파에 pole이 하나 더 생긴다. 결국, stability가 안좋아진다.<br />
<br />
이럴 경우, LHP zero를 하나 만들어서 phase를 보상하는 방식이 있다.<br />
C_load에 직렬로 ESR(Equivalent Series Resistor)를 붙여서 만들 수 있다.<br />
<br />
근데, 이 방식은 mismatch때문에 pole zero 위치가 움직이면 큰 문제가 생길 수도 있다.<br />
그리고 current load가 크게, 순식간에 변할 경우, Cout이 작으면 급격하게 변하는 전류가 저항에 흐를 수 있다.<br />
이럴 경우, 전압이 크게 흔들린다.<br />
<br /></p>
<div style="float: left">
    <img src="/public/img/LDO3.png" style="width: 50%; height: auto;" alt="my picture" />
</div>
<p><br />
\(p_0 = \dfrac{1}{R_{out}C_{load}}\)<br />
\(p_1 = \dfrac{1}{r_{oea}C_b}\)<br />
\(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)<br />
<br />
여기서, 사용하는 buffer의 \(C_b\)와 \(r_{ob}\)가 최대한 작은게 좋다. 그래야 \(p_1\), \(p_2\)가 모두 고주파로 날아가서 \(p_0\)밖에 안남는다.<br />
<br />
일단 이렇게 생긴 source follower를 buffer로 쓴다고 해보자.</p>

<div style="float: left">
    <img src="/public/img/LDO4.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>Source follower를 buffer로 쓰면 이런 상황이 된다.<br />
이때 \(C_b\), \(r_{ob}\)가 최대한 작은 값을 갖게 해야 한다.<br />
<br />
buffer의 small signal model을 생각해보면, \(r_{ob}=\dfrac{1}{g_{m1}}\)이 된다.<br />
따라서, \(r_{ob}\)를 줄이려면 \(g_{m1}\)를 최대한 늘려야 한다.<br />
<br />
\(g_{m1}\)을 늘리는 데에는 두가지 방법이 있다.<br />
\(I_1\)을 늘리는 방법이 있고, \(\dfrac{W_1}{L_1}\)을 늘리는 방법이 있다.<br />
<br />
근데, \(I_1\)를 늘리면 buffer가 먹는 전류가 늘어나는거라, \(I_Q\)가 늘어난다.<br />
그렇다고 \(\dfrac{W_1}{L_1}\)을 늘리면 트랜지스터 크기가 커져서 \(C_b\)가 늘어난다.<br />
<br />
그래서, 위 그림에서 사용된 simple source follower는 여기서 buffer로 사용하기에 부적합하다.<br />
<br />
<br />
source follower with negative feedback을 쓰는 방법이 있다.<br />
BJT를 feedback device로 사용해서, \(r_{ob}\)를 줄이는 구조다.<br /></p>

<div style="float: left">
    <img src="/public/img/LDO5.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>buffer 입장에서 출력 전압 노드인, \(M_p\)의 gate 전압이 증가한 경우를 생각해보면:<br />
\(M_1\)의 Vds가 증가했으니, channel length modulation에 의해 \(M_1\)의 Ids가 증가한다.<br />
근데, \(M_2\)의 Ids는 Current mirror 구조에 의해 고정되어 있다.<br />
그래서, \(M_1\)의 Ids가 증가한 만큼 \(Q_1\)의 Ib가 증가하게 된다.<br />
그러면 \(Q_1\)의 Ice는 \(\beta\)Ib만큼 증가한다.<br />
<br />
그래서, 원래 Vout이 Vx만큼 증가하면 전류가 gm1Vx만큼 증가했었는데,<br />
이제는 gm1Vx + \(\beta\)gm1Vx = (1+beta)gm1Vx만큼 증가하는 것이다.<br />
<br />
따라서 \(r_{ob}=\dfrac{1}{g_{m1}(1+\beta)}\)가 된다.<br />
이렇게 되면 rob가 확 줄어드니까, gm이 그렇게까지 안커도 된다. beta가 큰 값이니까.<br />
그래서 gm을 조금 포기하는 대신 I1을 줄여 IQ를 줄일 수 있고, W/L을 줄여 Cb를 줄일 수 있다.<br />
<br />
<br />
근데 또 문제가 있다. load current가 증가하면 unity gain frequency도 증가하는데,<br />
그러면 rob도 그에 맞춰 줄어들어줘야 한다.<br />
<br />
그렇지 않으면 unity gain frequency가 계속 증가하다가 \(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)보다 커질 수도 있다.<br />
그러면 unity gain frequency 이전에 pole이 하나 더 생기는거라, stability가 안좋아진다.<br />
<br />
그래서 이런 구조를 만들게 됐다.<br />
<br />
<br /></p>

<div style="float: left">
    <img src="/public/img/LDO6.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br />
일단, 이 buffer의 output resistance는:<br />
\(r_{ob} = \dfrac{1}{g_{m1}(1+\beta)} || \dfrac{1}{g_{m4}} = \dfrac{1}{g_{m1}(1+\beta)+g_{m4}}\)<br />
<br />
<br />
이 상태에서 \(M_p\)의 \(I_{DS}\)가 증가하면?<br />
일단 \(M_p\)의 Gate 전압이 줄어들어야 할 것이다. 그래야 \(I_{DS}\)가 증가하니까.<br />
그러면 \(M_4\)와 \(M_5\)의 \(|V_{GS}|\) 가 증가한다.<br />
그래서 \(M_4\)와 \(M_5\)의 \(I_{DS}\)가 증가하는데,<br />
<br />
\(M_4\)의 \(I_{DS}\)가 증가하면 \(g_{m4}\)가 증가하고,<br />
\(M_5\)의 \(I_{DS}\)가 증가하면 \(M_2\), \(M_3\)이 이루고 있는 current mirror에 의해 \(M_1\)에서도 전류가 증가한다. 따라서 \(g_{m1}\)이 증가한다.<br />
<br />
결국, Load Current가 증가해서 \(M_p\)의 \(I_{DS}\)가 증가하면<br />
\(g_{m4}\), \(g_{m1}\)이 증가해 \(r_{ob}\)가 작아진다.<br />
그래서 \(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)는 Load current가 있을 때에도 Unity Gain Frequency보다 높은 주파수에 있을 수 있다.<br />
<br />
<br />
참고자료: A transient-Enhanced Low-Quiescent Current Low-Dropout Regulator With Buffer Impedance Attenuation</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[LDO : Low Dropout Regulators IC가 제대로 동작하기 위해서는 흔들리지 않는 일정한 전압이 필요한 부분들이 있다. OP AMP 의 입력, MOSFET의 Gate 등 전류를 흐르게 하지 않는 노드면 BGR 회로(Bandgap Reference Circuit)으로 전압을 주면 되지만, 저항, Logic Gate 등 전류를 소모하는 load가 연결된 경우에는 BGR을 쓰면 전압이 이상하게 나온다. 그래서, 이때는 LDO라는 회로를 써줘야 한다.]]></summary></entry><entry><title type="html">Analog - LDO - Frequency Response</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Frequency-Response.html" rel="alternate" type="text/html" title="Analog - LDO - Frequency Response" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20LDO%20-%20Frequency%20Response</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-LDO-Frequency-Response.html"><![CDATA[<p><br />
Stability:<br />
어떤 주파수로 load current를 당겨도 LDO 출력전압이 안떨어질까?<br />
안타깝게도 그렇지는 않다. frequency response가 일정하지 못하다.<br />
<br />
그럼 frequency response를 어떻게 확인할 것인가?<br />
Loop Gain을 본다.<br /></p>

<div style="float: left">
    <img src="/public/img/LDO2.png" style="width: 40%; height: auto;" alt="my picture" />
</div>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[Stability: 어떤 주파수로 load current를 당겨도 LDO 출력전압이 안떨어질까? 안타깝게도 그렇지는 않다. frequency response가 일정하지 못하다. 그럼 frequency response를 어떻게 확인할 것인가? Loop Gain을 본다.]]></summary></entry><entry><title type="html">Analog - LDO</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-LDO.html" rel="alternate" type="text/html" title="Analog - LDO" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20LDO</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-LDO.html"><![CDATA[<p>LDO : Low Dropout Regulators<br />
<br />
<br />
IC가 제대로 동작하기 위해서는 흔들리지 않는 일정한 전압이 필요한 부분들이 있다.<br />
OP AMP 의 입력, MOSFET의 Gate 등 전류를 흐르게 하지 않는 노드면 BGR 회로(Bandgap Reference Circuit)으로 전압을 주면 되지만,<br />
<br />
저항, Logic Gate 등 전류를 소모하는 load가 연결된 경우에는 BGR을 쓰면 전압이 이상하게 나온다.<br />
그래서, 이때는 LDO라는 회로를 써줘야 한다.<br />
<br /></p>
<div style="float: left">
    <img src="/public/img/LDO1.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>PMOS를 써서 만들면 Common Source 구조가 되고,<br />
NMOS를 써서 만들면 Source Follower 구조가 된다.<br />
<br />
Stability:<br />
어떤 주파수로 load current를 당겨도 LDO 출력전압이 안떨어질까?<br />
안타깝게도 그렇지는 않다. frequency response가 일정하지 못하다.<br />
<br />
그럼 frequency response를 어떻게 확인할 것인가?<br />
Loop Gain을 본다.<br /></p>

<div style="float: left">
    <img src="/public/img/LDO2.png" style="width: 40%; height: auto;" alt="my picture" />
</div>

<p>LDO 만들때는:<br />
Low dropout voltage,<br />
high output current,<br />
low no-load quiescent current,<br />
small output transient undershoot<br />
이런 것들이 필요하다.<br />
<br />
LDO가 낮은 dropout voltage를 유지하면서 load current도 많이 공급해주려면, Pass device로 크기가 큰 PMOS를 써야 한다. W/L이 커야 해서.<br />
근데 크기가 큰 PMOS를 쓰면, 그 device의 C가 커진다.<br />
원래는 C_load에 의한 dominant pole만 저주파에 있었어야 했는데,<br />
PMOS의 C가 크면 저주파에 pole이 하나 더 생긴다. 결국, stability가 안좋아진다.<br />
<br />
이럴 경우, LHP zero를 하나 만들어서 phase를 보상하는 방식이 있다.<br />
C_load에 직렬로 ESR(Equivalent Series Resistor)를 붙여서 만들 수 있다.<br />
<br />
근데, 이 방식은 mismatch때문에 pole zero 위치가 움직이면 큰 문제가 생길 수도 있다.<br />
그리고 current load가 크게, 순식간에 변할 경우, Cout이 작으면 급격하게 변하는 전류가 저항에 흐를 수 있다.<br />
이럴 경우, 전압이 크게 흔들린다.<br />
<br /></p>
<div style="float: left">
    <img src="/public/img/LDO3.png" style="width: 50%; height: auto;" alt="my picture" />
</div>
<p><br />
\(p_0 = \dfrac{1}{R_{out}C_{load}}\)<br />
\(p_1 = \dfrac{1}{r_{oea}C_b}\)<br />
\(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)<br />
<br />
여기서, 사용하는 buffer의 \(C_b\)와 \(r_{ob}\)가 최대한 작은게 좋다. 그래야 \(p_1\), \(p_2\)가 모두 고주파로 날아가서 \(p_0\)밖에 안남는다.<br />
<br />
일단 이렇게 생긴 source follower를 buffer로 쓴다고 해보자.</p>

<div style="float: left">
    <img src="/public/img/LDO4.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>Source follower를 buffer로 쓰면 이런 상황이 된다.<br />
이때 \(C_b\), \(r_{ob}\)가 최대한 작은 값을 갖게 해야 한다.<br />
<br />
buffer의 small signal model을 생각해보면, \(r_{ob}=\dfrac{1}{g_{m1}}\)이 된다.<br />
따라서, \(r_{ob}\)를 줄이려면 \(g_{m1}\)를 최대한 늘려야 한다.<br />
<br />
\(g_{m1}\)을 늘리는 데에는 두가지 방법이 있다.<br />
\(I_1\)을 늘리는 방법이 있고, \(\dfrac{W_1}{L_1}\)을 늘리는 방법이 있다.<br />
<br />
근데, \(I_1\)를 늘리면 buffer가 먹는 전류가 늘어나는거라, \(I_Q\)가 늘어난다.<br />
그렇다고 \(\dfrac{W_1}{L_1}\)을 늘리면 트랜지스터 크기가 커져서 \(C_b\)가 늘어난다.<br />
<br />
그래서, 위 그림에서 사용된 simple source follower는 여기서 buffer로 사용하기에 부적합하다.<br />
<br />
<br />
source follower with negative feedback을 쓰는 방법이 있다.<br />
BJT를 feedback device로 사용해서, \(r_{ob}\)를 줄이는 구조다.<br /></p>

<div style="float: left">
    <img src="/public/img/LDO5.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p>buffer 입장에서 출력 전압 노드인, \(M_p\)의 gate 전압이 증가한 경우를 생각해보면:<br />
\(M_1\)의 Vds가 증가했으니, channel length modulation에 의해 \(M_1\)의 Ids가 증가한다.<br />
근데, \(M_2\)의 Ids는 Current mirror 구조에 의해 고정되어 있다.<br />
그래서, \(M_1\)의 Ids가 증가한 만큼 \(Q_1\)의 Ib가 증가하게 된다.<br />
그러면 \(Q_1\)의 Ice는 \(\beta\)Ib만큼 증가한다.<br />
<br />
그래서, 원래 Vout이 Vx만큼 증가하면 전류가 gm1Vx만큼 증가했었는데,<br />
이제는 gm1Vx + \(\beta\)gm1Vx = (1+beta)gm1Vx만큼 증가하는 것이다.<br />
<br />
따라서 \(r_{ob}=\dfrac{1}{g_{m1}(1+\beta)}\)가 된다.<br />
이렇게 되면 rob가 확 줄어드니까, gm이 그렇게까지 안커도 된다. beta가 큰 값이니까.<br />
그래서 gm을 조금 포기하는 대신 I1을 줄여 IQ를 줄일 수 있고, W/L을 줄여 Cb를 줄일 수 있다.<br />
<br />
<br />
근데 또 문제가 있다. load current가 증가하면 unity gain frequency도 증가하는데,<br />
그러면 rob도 그에 맞춰 줄어들어줘야 한다.<br />
<br />
그렇지 않으면 unity gain frequency가 계속 증가하다가 \(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)보다 커질 수도 있다.<br />
그러면 unity gain frequency 이전에 pole이 하나 더 생기는거라, stability가 안좋아진다.<br />
<br />
그래서 이런 구조를 만들게 됐다.<br />
<br />
<br /></p>

<div style="float: left">
    <img src="/public/img/LDO6.png" style="width: 50%; height: auto;" alt="my picture" />
</div>

<p><br />
일단, 이 buffer의 output resistance는:<br />
\(r_{ob} = \dfrac{1}{g_{m1}(1+\beta)} || \dfrac{1}{g_{m4}} = \dfrac{1}{g_{m1}(1+\beta)+g_{m4}}\)<br />
<br />
<br />
이 상태에서 \(M_p\)의 \(I_{DS}\)가 증가하면?<br />
일단 \(M_p\)의 Gate 전압이 줄어들어야 할 것이다. 그래야 \(I_{DS}\)가 증가하니까.<br />
그러면 \(M_4\)와 \(M_5\)의 \(|V_{GS}|\) 가 증가한다.<br />
그래서 \(M_4\)와 \(M_5\)의 \(I_{DS}\)가 증가하는데,<br />
<br />
\(M_4\)의 \(I_{DS}\)가 증가하면 \(g_{m4}\)가 증가하고,<br />
\(M_5\)의 \(I_{DS}\)가 증가하면 \(M_2\), \(M_3\)이 이루고 있는 current mirror에 의해 \(M_1\)에서도 전류가 증가한다. 따라서 \(g_{m1}\)이 증가한다.<br />
<br />
결국, Load Current가 증가해서 \(M_p\)의 \(I_{DS}\)가 증가하면<br />
\(g_{m4}\), \(g_{m1}\)이 증가해 \(r_{ob}\)가 작아진다.<br />
그래서 \(p_2 = \dfrac{1}{r_{ob}C_{pmos}}\)는 Load current가 증가하면 더 높은 주파수로 이동하기에,
항상 Unity Gain Frequency보다 높은 주파수에 있을 수 있다.<br />
<br /></p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[LDO : Low Dropout Regulators IC가 제대로 동작하기 위해서는 흔들리지 않는 일정한 전압이 필요한 부분들이 있다. OP AMP 의 입력, MOSFET의 Gate 등 전류를 흐르게 하지 않는 노드면 BGR 회로(Bandgap Reference Circuit)으로 전압을 주면 되지만, 저항, Logic Gate 등 전류를 소모하는 load가 연결된 경우에는 BGR을 쓰면 전압이 이상하게 나온다. 그래서, 이때는 LDO라는 회로를 써줘야 한다.]]></summary></entry><entry><title type="html">Analog - PLL</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-PLL.html" rel="alternate" type="text/html" title="Analog - PLL" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20PLL</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-PLL.html"><![CDATA[<p>PLL : Phase Locked Loops<br />
<br />
<br />
원래는 주파수 높은 clock을 만들려고 쓰지만, 동작 주파수가 낮은 경우에도 clock의 jitter를 없애기 위해 PLL을 쓰기도 한다.
PLL이 Lock되면, PLL block에서 Lock 신호를 high로 올려준다.
다른 block들은 그거 보고 동작하기 시작하면 된다.</p>

<p>chip이 켜지면 Analog trimming data 등 정보가 들어있는 Flash memory를 읽는데,
Flash memory를 PLL이 Lock 되기 전에 읽기도 한다. PLL이 Lock되는 데에는 시간이 좀 걸리니까, 시간 아끼기 위해서다.</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[PLL : Phase Locked Loops 원래는 주파수 높은 clock을 만들려고 쓰지만, 동작 주파수가 낮은 경우에도 clock의 jitter를 없애기 위해 PLL을 쓰기도 한다. PLL이 Lock되면, PLL block에서 Lock 신호를 high로 올려준다. 다른 block들은 그거 보고 동작하기 시작하면 된다.]]></summary></entry><entry><title type="html">Analog - Sigma-Delta ADC</title><link href="http://localhost:4000/design/2023/10/04/Design-Analog-Sigma-Delta-ADC.html" rel="alternate" type="text/html" title="Analog - Sigma-Delta ADC" /><published>2023-10-04T19:31:29+09:00</published><updated>2023-10-04T19:31:29+09:00</updated><id>http://localhost:4000/design/2023/10/04/Design%20-%20Analog%20-%20Sigma-Delta%20ADC</id><content type="html" xml:base="http://localhost:4000/design/2023/10/04/Design-Analog-Sigma-Delta-ADC.html"><![CDATA[<p>adf</p>]]></content><author><name></name></author><category term="Design" /><summary type="html"><![CDATA[adf]]></summary></entry></feed>