<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Seil Park" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>Seil Park</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/">Seil Park</a>
	</div>
	<p class="lead"></p></div>

<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title" style="text-align: center;">Introduction</li>
	  <li>
	  	<a class="nav-item" href="/">CV</a>
	  </li>
	  <li>
		<a class="nav-item" href="/research">Research</a>
	  </li>
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title" style="text-align: center;">Articles</li>
		
	    <li>
	    	<a class="nav-item" href="/category/#Design">
				<span class="name">Design</span>
				<span class="badge">26</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#History">
				<span class="name">History</span>
				<span class="badge">5</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Market">
				<span class="name">Market</span>
				<span class="badge">18</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Process">
				<span class="name">Process</span>
				<span class="badge">20</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Electromagnetics">
				<span class="name">Electromagnetics</span>
				<span class="badge">6</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
	<p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a></p>
</div>

		</div>
		<div class="content">
			<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			Digital - Serial Communication Protocols
		</div>
		<time class="post-date dt-published" datetime="2023-10-04T19:31:29+09:00" itemprop="datePublished">2023/10/04
		</time>		
	</header>

	<div class="post-content">
		<p>Serial Communication Protocolì—ëŠ” UART, I2C, SPIê°€ ìˆë‹¤.</p>

<p>UART (Universal Asynchronous Receiver-Transmitter):
UARTëŠ” deviceê°„ ë‹¨ê±°ë¦¬ í†µì‹ ì— ì“°ì´ëŠ” asynchronous serial communication protocolì´ë‹¤.
Â âœ” It uses two wires, one for transmitting data (TX) and another for receiving data (RX).
Â Â âœ” UART does not have a clock signal, so the data is transmitted asynchronously using start and stop bits to mark the beginning and end of each data frame.
Â Â âœ” It is a straightforward and simple protocol, commonly used in applications like serial communication between a microcontroller and a computer, GPS modules, and Bluetooth modules.</p>

<p>ğŸ”° 2. SPI (Serial Peripheral Interface):
Â âœ” SPI is a synchronous serial communication protocol primarily used for
communication between microcontrollers and peripheral devices, such as sensors, displays, and memory chips.
Â âœ” It requires four wires: a master-out-slave-in (MOSI) line for data transmission, a master-in-slave-out (MISO) line for data reception, a clock (SCK) line for synchronization, and a chip select (CS) line to select the target device.
Â âœ” SPI operates in a master-slave configuration, where a master device initiates the communication and controls the data transfer to one or more slave devices.
Â Â âœ” It supports full-duplex communication, meaning data can be simultaneously transmitted and received.
Â Â Â âœ” SPI is known for its high data transfer rates and is commonly used in applications that require fast and efficient data transfer.</p>

<p>ğŸ”° 3. I2C (Inter-Integrated Circuit):
Â Â Â âœ” I2C is a multi-master, multi-slave, and bidirectional serial communication protocol designed for communication between integrated circuits on a circuit board.
Â âœ” It uses two wires: a serial data line (SDA) for bidirectional data transfer and a serial clock line (SCL) for synchronization.
Â Â Â âœ” I2C allows multiple devices to share the same bus, with each device having a unique address.
Â Â Â âœ” It supports both 7-bit and 10-bit addressing modes, providing the capability to connect a large number of devices.
Â âœ” I2C is a slower protocol compared to UART and SPI, but it requires fewer wires and is commonly used in applications where simplicity and low pin count are important, such as sensors, EEPROM memory chips, and real-time clocks.
SDA: busë¥¼ í†µí•´ data ì „ë‹¬
SCL: master, slave ì‚¬ì´ data transferë¥¼ synchronizeí•œë‹¤.</p>

<p>I2Cê°€ ìœ„ 2ê°œë³´ë‹¤ ë‚˜ì€ ì :
Flexibility â€“ The I2C protocol supports multi-master, multi-slave communication, which implies you can add a lot of functionality to your design. More than one master IC controlling and communicating with the slave ICs can speed things up and add functionalities to the embedded system.</p>

<p>Addressing feature â€“ Yet another advantage of the I2C protocol lies in its inherent ability to use chip addressing. It means that you can easily add components to the bus without any complexity. It eliminates the necessity of CS (chip select) lines.</p>

<p>Simplicity â€“ I2C protocol doesnâ€™t complicate the design. It requires only two bidirectional signal lines to establish communication among multiple devices. Further, the pin count is low as well.</p>

<p>Better error handling mechanism â€“ To improve the error detection and correction mechanism, the I2C protocol relies on ACK/NACK feature, which is a robust error correction feature. ACK stands for Acknowledgement whereas NACK means No Acknowledgement.</p>

<p>Adaptable â€“ The I2C protocol is adaptable in the sense that it can work well with both slow ICs and fast ICs.</p>

<p>I2Cê°€ ìœ„ 2ê°œë³´ë‹¤ ì•ˆì¢‹ì€ì :
Conflicts â€“ Due to chip addressing, thereâ€™s always a possibility of an address conflict.</p>

<p>Slower speeds â€“ I2C protocol uses pull-up resistors rather than the push-pull ones used by its peers. Due to the open-drain design, the speed is limited.</p>

<p>Requires more space â€“ Now, as an embedded system engineer, you know how valuable PCB real estate is. So, it isnâ€™t such a positive attribute that the I2C protocol requires so much space for its pull-up resistors.</p>

<p>slaveëŠ” masterì—ê²Œ ACKì„ ë³´ë‚´ì•¼ í•œë‹¤.
ê·¸ë˜ì„œ ì‹ í˜¸ ë°›ê¸°ë§Œ í• ê±°ì—¬ë„ SDAëŠ” ì¶œë ¥ì„ ë³´ë‚¼ ìˆ˜ ìˆëŠ” êµ¬ì¡°ì—¬ì•¼ í•œë‹¤.</p>

<p>I2C í†µì‹ ìœ¼ë¡œ íŠ¹ì • code patternì„ ë„£ì–´ì•¼ íŠ¹ì • ë ˆì§€ìŠ¤í„°ë“¤ì— ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ í•˜ëŠ”ê²Œ protection ê¸°ëŠ¥ì´ë‹¤.
ì˜ˆë¥¼ ë“¤ì–´, analog trimming data ì˜ì—­ì€ ì‚¬ìš©ìê°€ ëª»ê±´ë“œë¦¬ê²Œ protectionì„ ê±¸ì–´ë†“ëŠ”ë‹¤. ì´ê±° ê±´ë“œë¦¬ë©´ ë™ì‘ì´ ì•„ì˜ˆ ì•ˆë ìˆ˜ë„ ìˆë‹¤.</p>

<p>I3C: Improved Inter-Integrated Circuit</p>

<p>I2C operates in five main modes:</p>

<p>Standard Mode: 100 kHz
Fast Mode: 400 kHz
Fast Mode Plus: 1 MHz
High Speed: 3.4 MHz
Ultra-Fast Mode: 5 MHz
I3C, on the other hand, has a Standard Data Rate of 12.5 MHz, with new versions of I3C supporting data rates up to 100 Mbps. Needless to say, I3C supports speeds that far surpasses that of I2C.</p>

<p>Backward Compatibility
When developing I3C, the ability for the protocol to be fully backward compatible was a significant focus. I3C applications can operate with I2C slave devices as well as native I3C devices. This backward compatibility allows engineers time to phase out their existing I2C applications. This phase-out time is necessary for embedded systems engineers because it makes the adoption of the new protocol much easier and streamlined.</p>

<p>Dynamic Addressing
I2C has a device addressing technique called static addressing. This, in simple terms, means that manufacturers lock in their device addresses in production. One of the drawbacks of this is that vendors may use the same address as another vendor for a product that uses I2C, causing issues during integration. During bus initialization, the I3C controller assigns a 7-bit dynamic address to each device on the I3C bus, thereby eliminating the problems associated with duplicate addresses because each I3C device receives a unique address from the master.</p>

<p>Hot-Join
Another new feature to I3C is the protocolâ€™s ability to allow other slave devices to be added or taken away from the system with no interrupts to the system as a whole. The system is called hot-join. This mechanism allows slaves to join the bus after the bus is already configured.</p>

<p>In-band Interrupt
The I3C interface uses a push-pull clock line and an open-drain data line for operations. The data line allows slaves to take control and initiate interrupts when needed. This feature is unique to I3C as this same application on the I2C bus would require a third line. I3C slaves can request an interrupt when the bus is idle, whereas I2C slaves cannot. I3C assesses conflicts between multiple slaves by allowing the lowest assigned address to win.</p>

<p>Power Efficiency
Another attribute important to any new technology is its ability to manage power consumption better than previous product iterations. Computers need to be faster but use much less energy than the prior model; new iterations of bus protocols are no different.</p>

<p>Due to a change in output method from an open drain method to a push-pull output, I3C can be much more energy efficient than I2C. An open-drain process requires pull-up resistors that, when activated, require a significant amount of power to operate. Push-pull operations do not require pull-up resistors to work, meaning the method can reduce energy consumption because it does not need to power any external resistors to function.</p>

<p>Another factor that plays into the power-saving quality of I3C over I2C is its data transfer speed improvements. The benefits here are simple to understand. Because messages can now be sent over the I3C bus at significantly faster rates, the bus can turn on and shut off target devices much quicker than was possible with I2C. This process saves a noticeable amount of power consumption compared to I2C.</p>

	</div>
</article>
		</div>
	</div>
  </body>
</html>