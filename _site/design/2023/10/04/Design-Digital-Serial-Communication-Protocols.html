<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Seil Park" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>Seil Park</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/">Seil Park</a>
	</div>
	<p class="lead"></p></div>

<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title" style="text-align: center;">Introduction</li>
	  <li>
	  	<a class="nav-item" href="/">CV</a>
	  </li>
	  <li>
		<a class="nav-item" href="/research">Research</a>
	  </li>
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title" style="text-align: center;">Articles</li>
		
	    <li>
	    	<a class="nav-item" href="/category/#Design">
				<span class="name">Design</span>
				<span class="badge">22</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Market">
				<span class="name">Market</span>
				<span class="badge">17</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Process">
				<span class="name">Process</span>
				<span class="badge">20</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Electromagnetics">
				<span class="name">Electromagnetics</span>
				<span class="badge">6</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
	<p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a></p>
</div>

		</div>
		<div class="content">
			<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			Digital - Serial Communication Protocols
		</div>
		<time class="post-date dt-published" datetime="2023-10-04T19:31:29+09:00" itemprop="datePublished">2023/10/04
		</time>		
	</header>

	<div class="post-content">
		<p>Serial Communication Protocol에는 UART, I2C, SPI가 있다.<br />
최근에는 I2C를 개선한 I3C가 도입되고 있다.<br />
<br />
<br />
UART (Universal Asynchronous Receiver-Transmitter):<br />
UART는 device간 단거리 통신에 쓰이는 asynchronous serial communication protocol이다.<br />
<br />
UART 통신은 전선 2개를 사용한다.<br />
하나는 데이터 송신용(Tx), 하나는 데이터 수신용(Rx)이다.<br />
<br />
UART 통신은 clock 신호를 사용하지 않는다.<br />
그래서 각 data frame 앞뒤로 start bit, stop bit가 있어야 한다.<br />
<br />
UART는 구조가 간단한 통신 방식이다.<br />
GPS, 블루투스 등에 쓰인다.<br />
<br />
<br />
SPI (Serial Peripheral Interface):<br />
<br />
SPI는 전선 4개를 사용한다.<br />
MOSI (Master Out Slave In): Data 송신<br />
MISO (Master In Slave Out): Data 수신<br />
SCLK (Serial Clock): Clock 신호<br />
CS (Chip Select): 대상 device 선택<br />
<br />
SPI 통신은 master-slave 구조로 진행된다.<br />
master가 통신을 시작해서, 1개 또는 여러개 slave로 데이터를 전송한다.<br />
<br />
Full-duplex 통신을 지원한다. 데이터를 전송하면서 동시에 데이터를 받을 수 있다는 뜻이다.<br />
<br />
SPI는 데이터 전송 rate가 높아서,<br />
빠르고 효율적인 데이터 전송이 필요한 곳에 쓰인다.<br />
<br />
<br />
I2C (Inter-Integrated Circuit):<br />
<br />
I2C는 multi-master, multi-slave 통신이기 때문에 유연한 설계가 가능하다.<br />
<br />
I2C는 bidirectional 통신이기 때문에 slave로부터 ACK, NACK 신호를 받아서 통신 성공 여부를 확인할 수 있다.<br />
통신에 성공했으면 ACK 신호, 실패했으면 NACK 신호가 돌아온다.<br />
<br />
<br />
I2C는 2개 전선을 쓴다.<br />
SDA (Serial Data Line): 양방향 데이터 송수신<br />
SCL (Serial Clock Line): Clock 신호<br />
<br />
I2C는 addressing을 하기 떄문에, 여러개 device가 1개 bus에 연결될 수 있다.<br />
<br />
I2C는 SPI, UART보다 느리지만 더 간단한 구조고 전선도 덜 쓴다.<br />
그래서 pin이 적어야 하는 센서, EEPROM 메모리칩, real-time clock 등에 쓰인다.<br />
<br />
<br /></p>

<p>I3C:</p>

<p>I2C가 위 2개보다 안좋은점:
Conflicts – Due to chip addressing, there’s always a possibility of an address conflict.</p>

<p>Slower speeds – I2C protocol uses pull-up resistors rather than the push-pull ones used by its peers. Due to the open-drain design, the speed is limited.</p>

<p>Requires more space – Now, as an embedded system engineer, you know how valuable PCB real estate is. So, it isn’t such a positive attribute that the I2C protocol requires so much space for its pull-up resistors.</p>

<p>slave는 master에게 ACK을 보내야 한다.
그래서 신호 받기만 할거여도 SDA는 출력을 보낼 수 있는 구조여야 한다.</p>

<p>I2C 통신으로 특정 code pattern을 넣어야 특정 레지스터들에 접근 가능하도록 하는게 protection 기능이다.
예를 들어, analog trimming data 영역은 사용자가 못건드리게 protection을 걸어놓는다. 이거 건드리면 동작이 아예 안될수도 있다.</p>

<p>I3C: Improved Inter-Integrated Circuit</p>

<p>I2C operates in five main modes:</p>

<p>Standard Mode: 100 kHz
Fast Mode: 400 kHz
Fast Mode Plus: 1 MHz
High Speed: 3.4 MHz
Ultra-Fast Mode: 5 MHz
I3C, on the other hand, has a Standard Data Rate of 12.5 MHz, with new versions of I3C supporting data rates up to 100 Mbps. Needless to say, I3C supports speeds that far surpasses that of I2C.</p>

<p>Backward Compatibility
When developing I3C, the ability for the protocol to be fully backward compatible was a significant focus. I3C applications can operate with I2C slave devices as well as native I3C devices. This backward compatibility allows engineers time to phase out their existing I2C applications. This phase-out time is necessary for embedded systems engineers because it makes the adoption of the new protocol much easier and streamlined.</p>

<p>Dynamic Addressing
I2C has a device addressing technique called static addressing. This, in simple terms, means that manufacturers lock in their device addresses in production. One of the drawbacks of this is that vendors may use the same address as another vendor for a product that uses I2C, causing issues during integration. During bus initialization, the I3C controller assigns a 7-bit dynamic address to each device on the I3C bus, thereby eliminating the problems associated with duplicate addresses because each I3C device receives a unique address from the master.</p>

<p>Hot-Join
Another new feature to I3C is the protocol’s ability to allow other slave devices to be added or taken away from the system with no interrupts to the system as a whole. The system is called hot-join. This mechanism allows slaves to join the bus after the bus is already configured.</p>

<p>In-band Interrupt
The I3C interface uses a push-pull clock line and an open-drain data line for operations. The data line allows slaves to take control and initiate interrupts when needed. This feature is unique to I3C as this same application on the I2C bus would require a third line. I3C slaves can request an interrupt when the bus is idle, whereas I2C slaves cannot. I3C assesses conflicts between multiple slaves by allowing the lowest assigned address to win.</p>

<p>Power Efficiency
Another attribute important to any new technology is its ability to manage power consumption better than previous product iterations. Computers need to be faster but use much less energy than the prior model; new iterations of bus protocols are no different.</p>

<p>Due to a change in output method from an open drain method to a push-pull output, I3C can be much more energy efficient than I2C. An open-drain process requires pull-up resistors that, when activated, require a significant amount of power to operate. Push-pull operations do not require pull-up resistors to work, meaning the method can reduce energy consumption because it does not need to power any external resistors to function.</p>

<p>Another factor that plays into the power-saving quality of I3C over I2C is its data transfer speed improvements. The benefits here are simple to understand. Because messages can now be sent over the I3C bus at significantly faster rates, the bus can turn on and shut off target devices much quicker than was possible with I2C. This process saves a noticeable amount of power consumption compared to I2C.</p>

	</div>
</article>
		</div>
	</div>
  </body>
</html>