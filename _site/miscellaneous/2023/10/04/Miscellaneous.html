<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Seil Park" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>Seil Park</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/">Seil Park</a>
	</div>
	<p class="lead"></p></div>

<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title" style="text-align: center;">Introduction</li>
	  <li>
	  	<a class="nav-item" href="/">About</a>
	  </li>
	  <li>
		<a class="nav-item" href="/research">Research</a>
	  </li>
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title" style="text-align: center;">Articles</li>
		
	    <li>
	    	<a class="nav-item" href="/category/#Electromagnetics">
				<span class="name">Electromagnetics</span>
				<span class="badge">3</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Circuits">
				<span class="name">Circuits</span>
				<span class="badge">5</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#History">
				<span class="name">History</span>
				<span class="badge">20</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Market">
				<span class="name">Market</span>
				<span class="badge">12</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Miscellaneous">
				<span class="name">Miscellaneous</span>
				<span class="badge">11</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Process">
				<span class="name">Process</span>
				<span class="badge">9</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Time-Frequency">
				<span class="name">Time-Frequency</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
	<p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a></p>
</div>

		</div>
		<div class="content">
			<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			Miscellaneous
		</div>
		<time class="post-date dt-published" datetime="2023-10-04T19:31:29+09:00" itemprop="datePublished">2023/10/04
		</time>		
	</header>

	<div class="post-content">
		<p>ESD Cell: Device에서 Electrostatic Discharge(ESD)가 일어나지 못하도록 하는 protection circuit이다. 여기서 ESD는 전하가 한 곳에 모여있다가 한번에 흐르는 현상이다.<br />
<br />
Timing Margin: 신호가 늦게 도착해도 회로가 정상동작할 수 있는 최대 시간이다. 신호가 timing margin보다 늦게 오기 시작하면 회로가 오동작하게 된다.<br />
<br />
Firmware: 하드웨어에 내장된 소프트웨어다. 이론적으로 컴퓨터는 CPU와 RAM만 있으면 사용 가능해야 하지만, CPU와 RAM이 서로 제어, 통신을 하려면 펌웨어가 저장된 메모리 모듈이 필요하다. 부품끼리 통신하는 데에 쓰이는 프로토콜은 상당히 복잡하기 때문에, 펌웨어가 그만큼 중요하다.
옛날에는 펌웨어를 ROM에 저장했어서 수정이 불가능했지만, 요즘은 플래시메모리에 저장하는 경우가 많아져 업데이트나 복구가 더 쉬워졌다. 펌웨어에 문제가 생기면 기기가 벽돌이 되니 조심해야 한다.<br />
<br />
PCI Bus: Peripheral Component Interconnect Bus<br />
컴퓨터 메인보드에 주변 장치를 장착하는데에 쓰이는 컴퓨터 버스의 일종이다.<br />
<br />
PXI: PCI eXtensions for Instrumentation<br />
여러가지 장비들을 측정, 제어하는데에 사용되는 플랫폼이다.<br />
<br />
Netlist: Circuit synthesis한 결과<br />
내가 적은 Verilog등 코드를 회로로 만들어놓은 것이 Netlist다.<br />
<br />
Netlist라는 회사도 있다. 나스닥에 상장된 메모리 반도체 모듈 회사다. NLST 티커로 상장되어 있다. LG반도체 출신 홍춘기라는 사람이 대표고, 2020년에 삼성전자와 특허 분쟁을 겪은 적이 있다고 한다.<br />
<br />
테스트 양산 엔지니어:<br />
1. Fab 내에서 발생한 HW, SW 문제들을 디버깅하여 수율을 관리<br />
2. 고객사가 문제를 제기할 때 QA팀, 회로설계팀, Product팀과 회의해서 어디가 원인인지 분석한다.<br />
3. 테스트 개발팀에서 새로운 테스트 아이템이 개발되면 그걸 구현하기 위한 테스트 프로그램을 만든다.<br />
<br />
테스트 개발 엔지니어:<br />
1. TTR을 위한 테스트 프로그램을 만들고, 하드웨어 관점에서도 TTR을 위한 방안을 모색한다.<br />
2. 고객사 의뢰 또는 회사 경쟁력을 위해 새로운 테스트 아이템을 연구해서 양산에 적용될 수 있도록 한다.<br />
3. 테스트 양산 엔지니어에게 전달할 Test plan sheet를 제작한다.<br />
<br />
QA팀: Quality Assurance, 품질보증팀<br />
TTR: Test Time Reduction<br />
<br />
테스트 양산 엔지니어, 테스트 개발 엔지니어 모두가 추구하는 목표는 TTR이다. 한번에 더 많은 칩을 테스트할 방법 연구, 테스트 프로그램 안의 불필요한 코드 수정 등을 통해 TTR을 줄인다.<br />
<br />
Test Plan Sheet에는:<br />
1. 테스트 양산 진행 방식(테스트 조건):<br />
Ex) leakage current를 재고 싶으면 이런 식으로 재라<br />
2. 이론적으로 나와야 할 값:<br />
Leakage current는 700nA정도 나와야 하며, 딱 이정도는 아니겠지만 하여간 1uA 아래로 나와야 한다<br />
3. Schematic:<br />
피스파이스 같은 회로는 아니고 Visio라는 Block Diagram용 schematic을 그려놓는다. 테스트 양산 엔지니어들은 이 그림을 보고 어디 소자가 불량이라 결과가 이렇구나 생각을 한다.<br />
<br />
메탈 이후 공정이 백엔드 공정이다.<br />
마이너리비전: 메탈쪽만 리비전<br />
메이저리비전: 모두 리비전<br />
<br />
White noise 줄이려면 크기랑 전력이 필요하다. 그래서 크기 키우고 전류 높이면 white noise가 줄어든다.<br />
<br />
SMT(Surface Mount Technology): Through-hole이나 점프선 같은 추잡한 방식 안쓰고 그냥 PCB 위에 IC 연결하는 방식이다.<br />
<br />
저항중에 작은 네모로 되어있는 저항도 있다. 얘네는 SMD(Surface Mounted Device)저항이라 불린다.<br />
<br />
위에서 말한 migration은 electromigration이다. 흐르는 전류 안의 전자가 도체 원자를 하도 때려서 원자가 밀려나는 현상이다. 이 현상은 J가 커질수록 많이 발생하기에, IC 크기가 작아질수록 중요하다. 이거 때문에, 오래 쓰면 도체가 너덜너덜해지거나 끊어진다. 도체 수명을 알려주는 식이 Black’s equation이다.<br />
<br />
Varactor diode: Voltage dependent capacitance를 제공하는 diode. PN junction의 depletion region을 capacitance로 쓴다. 이때 depletion region의 두께는 sqrt(양단전압)에 비례하니까, C가 1/sqrt(V)에 비례한다. 기호 사진 넣고<br />
Varactor diode는 RF회로, 통신회로에 많이 쓰인다.<br />
<br />
TTL(Transistor-Transistor Logic)은 BJT로 만들고, CMOS회로는 MOSFET으로 만든다. 왜 TTL을 BJT로 만드는지는 확인해봐야 한다.<br />
<br />
Shmoo plot: [슈모 plot] 어떤 시스템이 온도, 전압등의 조건들이 바뀔 때 보여주는 출력을 2차원으로 정리한 plot이다. 이 분야에서는 만들어진 IC가 다양한 조건의 테스트들에서 보여준 결과들을 2차원으로 정리한 plot을 말한다.<br />
<br />
EDS테스트를 하면 EDS 산포 데이터가 나온다.<br />
EDS1: 메모리 테스트 위주, 열가속 테스트. 85도 사용<br />
EDS2: 모든 항목을 테스트, 상온 사용<br />
이게 DW7601에만 이렇게 테스트한건지 아니면 다 이렇게 하는건지는 모르겠다.<br />
<br />
EDS 산포데이터를 확인한 후에는 trimming을 통해 산포도를 줄인다. 문제의 원인을 찾는건 보통 어려운 일이라, 그냥 trimming으로 어느정도 해결하고 넘어가버린다.<br />
<br />
Level shifter는 3.3V logic과 1.8V logic을 연결하기 위해 전압을 바꾸는 곳이다. 여기는 high voltage 소자와 low voltage 소자가 모두 있어서 문제가 자주 생기는 곳이다.<br />
<br />
캐패시터 용량은 3자리 수로 나타내는 경우가 있다. 103 이런 식으로. 이거는 10*10^3pF이란 뜻이다.<br />
다이오드는 띠 있는 쪽이 회로도에서 세로선이다. 사진 넣기.<br />
<br />
신뢰성 테스트는 높은 온도에서 진행하기 때문에, 소자 값이 변한다. 원래는 100옴짜리 저항을 넣었는데 온도가 변해서 120옴이 되어버린다든가 하는 식이다.<br />
<br />
SMD는 저항값이 voltage dependent라서, 전압 바꾸면 저항값이 많이 변한다.<br />
<br />
저항 값이나 캐패시턴스 값은 같은데 소자 크기가 많이 차이나는 경우가 있다. 이거는 정격 전압이 달라서 그렇다. 큰게 정격전압이 더 높은 소자다.<br />
<br />
Current probe는 앙페르의 법칙을 활용한 자기 센서다.<br />
<br />
인덕터 들어가는 회로면 OVP(Over Voltage Protection) 설정해놓고 실험해야 한다. 전압이 높게 튈 수 있다.<br />
<br />
전선을 손으로 잡았더니 noise가 없어지는 경우가 있다. 이때는 전선을 잡은 손이 캐패시터 역할을 한거다.<br />
<br />
OCP도 있다. Over Current Protection이다. 전압, 전류가 각각 OVP, OCP값을 넘으면 power supply가 꺼져버린다.<br />
<br />
Display limit이란 기능도 있는데, 이건 보여주는 데에만 한계를 거는 기능이다. 예를 들어 display limit을 200mA로 걸어놓으면, 전류가 증가해도 보이는건 200mA로만 보인다. 하지만 실제로는 210mA, 220mA로 계속 올라가고 있다.<br />
<br />
OCP는 보통 사용하는 최대전류의 1.5배로 한다. 즉 마진을 1.5배로 잡는다.<br />
전류가 A단위가 될 정도로 크면 최대전류의 1.2배로 하기도 한다.<br />
<br />
PCB는 그 자체로 방열판 기능이 있다. 그래서 IC 납땜할때 온도가 부족하면 납이 중간에 식어버릴 수도 있다. 그렇다고 너무 뜨거운 온도를 쓰면 PCB나 패키지가 타버린다.<br />
<br />
17bit 출력에서, variation이 200code면 2^8정도 되니까, 이때는 정보량이 17-8 = 9bit밖에 안된다. 즉, 9bit랑 다를게 없다.<br />
<br />
메모리 칩이나 로직 칩은 L을 무조건 작게 만들려고 하지만, 아날로그 칩은 그렇지 암ㅎ다. 당연히 L이 줄어들면 면적이 줄어드니까 경제적이긴 하지만,<br />
1. Mismatch, 1/f noise를 줄이려면 L을 늘려야 한다.<br />
2. L&lt;3~4um부터는 L이 조금만 변해도 Vth가 엄청나게 변한다. 즉, process variation이 심해져서 chip간 variation이 심해진다. 그래서 보통 L을 4um 이상 어딘가 variation 적은 곳에 둔다.<br />
이런 이유로, 아날로그 회로에서는 L을 무작정 줄이지 않는다.<br />
<br />
Netlist: Network + List, 소자들의 연결 상태를 보여주는 파일이다.<br />
<br />
Netlist 안의 소자들을 instance라고 부르는데, 이 instance들은 각자 terminal을 갖고 있다. 얘네가 wire로 이어져서 network가 생기고, 어떻게 연결되어있는지를 적는게 netlist다.<br />
<br />
netlist에도 종류가 있다. SPICE같은 instance-based netlist와 EDIF같은 net-based netlist가 있다.<br />
<br />
netlist보다 정보가 더 많다면, 그건 verilog나 VHDL같은 Hardware Description Language가 된다.<br />
<br />
2021년에, 반도체 수급이 안되자 fab들이 8인치 단가를 비싸게 불러놨는데, 수급이 생각보다 빠르게 월활해져서 8인치 팹이 많이 놀게 되었다. 그래서 fab이 2023년 초에 많이 노는 상황이었다.<br />
12인치, 60nm 이하 공정은 지금도 예약이 꽉 차있지만, 8인치 팹은 2022년부터는 full-capacity로 돌아가지 못하고 있다. 지금 어떤지는 모르겠다.<br />
<br />
ADC 스펙을 보려면 LPE를 봐야 한다. 근데, cosim에서 LPE를 하면 좀 이상하게 나올 때가 있었다. Spectre는 문제가 없어서 netlist까지는 멀쩡히 나오는데, verilog에서 만들어진 layout을 보면 좀 이상한 부분이 있었다. 그래서 cadence의 다른 프로그램인 QRC를 써볼까 생각중이다.<br />
<br />
MOSFET의 W를 2배로 만드록 싶은 경우, W를 2배로 새로 만드는것보다 그냥 MOSFET 2개를 병렬로 연결하는게 낫다. MOSFET 끄트머리 때문에 Weff가 정확히 2배가 안되니까.<br />
<br />
근데 이렇게 해도 mismatch가 충분히 줄어들지 않으면, 그때는 ‘layout을 섞어야 한다’.<br />
<br />
Jarque-Bera test:<br />
주어진 데이터의 skewness와 Kurtosis가 normal distribution과 얼마나 일치하는지 확인하는 테스트다.<br />
<br />
Multi stage noise shaping(MASH):<br />
회로의 차수를 높여서, 주파수 영역에서의 반응을 더 날카롭게 만들고 싶을 수 있다. 근데 회로에 stage를 여러 개 붙이면 차수가 올라가긴 하지만, 붙인 만큼 pole도 늘어나서 회로가 쉽게 발진할 수 있다.<br />
그래서 회로에서는 3stage 이상 안쓰고, 4stage 이상을 쓰더라도 아주 신중히 써야 한다.<br />
MASH가 하려는건 안전하게 차수를 올리려는거다. 근데 직렬로 연결 안하고 병렬로 더하는 방식이다. 이래야 발진 안하니까.<br />
<br />
그래서 이 방법에서는 4차도 2+2로 만든다.<br />
<br />
Bonding에 쓰이는 금이든 구리든, bonding에 쓰려고 가는 선으로 만들어놓으면 나중에 연결하며 인덕턴스를 생각해야 한다. 이 선들에 의해 인턱턴스가 크게 걸리기 때문이다.<br />
<br />
AMBA(Advanced Microcontroller Bus Architecture):<br />
ARM사의 BUS protocol을 말한다. AHB, ASB, APB, AXI가 있다.<br />
<br />
AHB(Advanced High Performance Bus):<br />
고속으로 동작하는 장치들이 연결된 bus<br />
<br />
ASB(Advanced System Bus)<br />
고속으로 동작하고, AHB와 달리 Rising Edge와 Falling Edge 모두 사용한다.<br />
<br />
APB(Advanced Peripheral BUS):<br />
비교적 느린 속도로 주변 장치들을 제어하며, 전력효율을 위해 간단한 인터페이스를 갖는다.<br />
<br />
AXI(Advanced eXtensible Interface):<br />
다중채널 연결용 버스다.<br /></p>

<p>Silicide는 Si에 Ti나 W를 섞은 물질로, 저항이 아주 작다.
근데 hr이 붙은 저항소자들은 도핑을 해서 저항을 올려놓은거다.
도핑을 추가로 하기 때문에 레이어가 하나 더 필요하긴 하지만, 그래도 엄청 큰 저항들을 만들 수 있다.</p>

<p>PAD capacitance: ESD가 옆에 있어서 발생하는 capacitance다. 보통 1pF 정도로 놓고 시뮬레이션한다.</p>

<p>회로 설계자가 조절할 수 있는 부분: 트랜지스터 크기, 연결 구성, 전압</p>

<p>디지털을 쓰는 이유:
노이즈가 없고, CMOS에서 한쪽만 켜져서 전류가 안흐른다. 아날로그는 애매한 전압이 들어와서 둘 다 켜져버릴 수도 있다. 이러면 전류가 흘러 power loss가 발생한다.</p>

<p>Jim Keller 강연 내용:
사람들은 RISC-V로 설계 많이 한다. 인텔, 암드꺼 ISA는 걔네밖에 못쓰기 때문이다.
여기서 보여준게 Ascalon O-o-O superscalar processor다. Tenstorrent에서 만든거다.</p>

<p>요즘 AI로 코드 짜는거 긍정적으로 언급했다.</p>

<p>RISC-V는 생각보다 좋은 구조다! 인텔, ARM의 구조에서 돌아가게 쓴 코드도 RISC-V에서 잘 돌아간다.</p>

<p>여기서 Scalar competition landscape 보여줬는데, 이게 뭔지는 뒤에 적어놓겠다. 일단 다양한 processor들 성능 보여주는 그래프였다.</p>

<p>Tenstorrent는 다음 세대 칩 설계도 시작했다. 다음 세대는 AI generated code를 써서 만들 것이기 때문에, 지금 세대보다 150~200%정도 향상된 성능을 보여줄 것이다.</p>

<p>Tenstorrent에서는 설계를 할 때, 일단 큰 설계를 만들고 하나하나 빼가면서 작아지게 발전시킨다.</p>

<p>지금 RISC-V 칭찬 많이 하긴 했지만, 그렇다고 무조건 ARM보다 RISC-V가 빠르다는건 아니다.</p>

<p>AMBA: ARM에서 정의한 on-chip interconnect protocol
AMBA = Advanced Microcontroller Bus Architecture</p>

<p>AMBA에는 여러가지 Bus protocol들이 있다.
APB = Advanced Peripheral Bus
낮은 Bandwidth를 갖는 주변기기(peripheral)를 위한 bus protocol</p>

<p>AHB: Advanced High-performance Bus
APB보다 높은 성능을 갖는다. 64/128bit를 지원하고, multi-master도 가능하다.
AHB-Lite는 single master를 위한 bus protocol이다.</p>

<p>AXI: Advanced eXtensible Interface
A/D phases, bursts, multiple outstanding addresses, OoO response를 지원한다.</p>

<p>ACE = AXI Coherency Extensions
ACE는 AXI의 superset이다. ACE는 multicore cluster들에 system-wide coherency를 제공한다.</p>

<p>CHI: Coherent Hub Interface
CHI는 credited coherency protocol, layered architecture for scalability</p>

<p>뒤로 갈수록 새로 나온거다. APB가 제일 옛날, CHI가 제일 최근에 나왔다.
AMBA도 AMBA4, AMBA5 이런 식으로 세대가 있다.
CHI는 AMBA5에 추가된 Bus protocol이다.</p>

<p>MSHR : Miss Status Holding Register</p>

<p>CPU가 명령어를 수행하려 했는데 거기 필요한 데이터가 Cache에 존재하지 않을 경우, Cache miss가 발생했다고 말한다.</p>

<p>Cache miss가 발생하면 필요한 데이터를 cache로 가져와야 하는데, 이 과정에서 MSHR을 사용한다.</p>

<p>Jim Keller가 언급한건 AXI, CHI, MSHR</p>

<p>Whisper, spike: RISC-V based ISA simulator
Instruction Set Simulator를 줄여서 ISS라고도 쓴다.</p>

<p>UVM: Universal Verification Methodology
Verilog로 만든 설계를 검증하기 위해 쓰이는 testbench중 하나가 UVM
요즘은 ISA뿐 아니라 UVM, RTL도 open source simulation에서 가능하다.</p>

<p>Jim Keller는 computer design을 40년동안 해왔다. 사용한 언어는 항상 C언어였고, 다른 언어를 쓰더라도 Rust같이 C랑 비슷한 언어였다. 얘네를 왜 썼냐면, 다 instruction 만들려고 쓴거다.</p>

<p>내가 코드를 적고 실행하면, 컴퓨터는 내부에서 instruction들을 만들어 동작한다.
근데 AI연산은 행렬 곱셈이다. 즉 instruction 만드는거랑은 상당히 다른 일을 해야 하는거다.
이건 계산이잖아? 그래서 구조도 완전히 다른 구조가 필요하다.</p>

<p>CPU: C언어를 쓰고, 1 [instruction/clock]보다 빠를 수 없다.
GPU: 병렬 연산으로 여러 개를 동시에 돌려서 빠르다.</p>

<p>AI는 지금 primitive 단계다.</p>

<p>tenstorrent에서는 processor들에 Tensix core라는걸 수백개 박아서, 각 Cell들이 서로 대화하게 만들었다.</p>

<p>Tenstorrent는 2개 software를 만들었는데, 각자 다른 approach로 동작한다.
PyBUDA : top-down, METAL : Bottom-top</p>

<p>여기 그림
그림에서 CPU cells : RISC-V cluster</p>

<p>BERT: Bidirectional Encoder Representations from Transformers
구글에서 만든 자연어처리 모델이다.
모델의 크기에 따라 BERT_base 모델과 BERT_large 모델이 있다.</p>

<p>요즘 보면 AI 스타트업이라면서 GPU만 하는 놈들이 많다.</p>

<p>Chiplet: chip을 만들 때, chip을 하나의 die에 만들지 않고 따로 만든 후 패키징할 때 합치는 방식이다.
왜 chiplet을 쓰는가? 수율 개선, 가격경쟁력, 더 쉬운 제조를 위해서다.</p>

<p>CPU를 만들 경우, 일부 영역에 문제생겨서 core 하나가 동작하지 않을 경우에도 CPU를 통째로 버려야 한다. 하지만 chiplet 기술을 쓴다면 그부분 die만 버리고 다른 정상 die를 가져와 패키징하면 된다. 그래서 chiplet을 쓰면 수율이 개선된다.</p>

<p>그리고, chip의 일부 영역에 한해서만 고가 공정을 맡기면 되니 가격이 개선된다.
게다가 다른 chip을 만들 때도 기존의 chiplet을 재활용할 수 있기에 신제품 개발 및 제조에도 도움이 된다.</p>

<p>Jim Keller는 chiplet을 언급하면서, 패키징을 개선했다고 했다.</p>

<p>tenstorrent에서 만들려는 것은 (RISC-V CPU) + (RISC-V AI)다. 그걸 위해, 개인이 마음껏 설정할 수 있는 CPU chiplet + AI chiplet을 만들려고 한다. 이런 칩들은 테슬라 등 자동차에도 들어갈거다.</p>

<p>너네 chip 만들려면 변호사도 필요하다.</p>

<p>Q. DEC Alpha CPU 개발 왜 접었나?
90년대 초반 컴퓨터 개발에서는 컴퓨터 성능 경쟁 = Instruction 수 늘리기 경쟁이었다.
이때, 반대로 instruction 수 줄여서 속도 개선한게 Alpha Chip이었다.</p>

<p>그리고 chip이 커지는 동안 microcode는 그대로였기에, alpha chip은 microcode도 개선했다.
하지만 윈도우 체제가 아니었기에 마이크로소프트가 싫어했고, 결국 묻혔다.</p>

<p>하지만 지금 봐라. 내가 옳았다. RISC가 맞다!</p>

<p>Microcode: CPU에 기계어를 쉽게 추가할 수 있도록 하는 code.
예를 들어, 덧셈뺄셈만 가능한 CPU에 곱셈을 추가하려면 덧셈을 반복하는 프로그램이 필요하다. 이런게 microcode다.</p>

<p>Q. 산업계가 RISC-V를 받아들이고 있는가?
기존 기술보다 RISC-V가 10배 빠르면 받아들일거다.
근데 기존 기술보다 5%정도 좋은 정도로는 절대 안바뀔거다.</p>

<p>RISC-V 기반 프로세서들이 기존 제품보다 10배 좋지는 못하다.
하지만 10배 성능이 나오게 되면 모두 바뀔거다.</p>

<p>가격도 그렇다. ARM 기반 프로세서 대비 RISC-V 기반 프로세서의 라이선스 비용이 1/10이 되면 핸드폰에도 다 RISC-V 칩이 들어갈 거다.
앞으로 2~3년 내에 RISC-V 폰이 나올 거라고 생각한다.</p>

<p>Q. 왜 프로세서마다 DRAM이 달려있나?
각 레이어에서 계산해줘야 하기 때문이다.</p>

<p>레이어 크기를 바꾸려고 할 때, CUDA는 그걸 다 코딩해줘야 한다. 그건 꽤나 어려운 일이다.
하지만 Tenstorrent processor는 그걸 자동으로 해준다.</p>

<p>Q. 요즘 AI 스타트업들이 많은데, Tenstorrent는 무엇이 특별한가?
나는 투자를 많이 받았다.
Tenstorrent 조사.
Tenstorrent 본사는 캐나다 토론토에 있다. Office는 미국 시애틀, 산타클라라, 오스틴, 보스턴, 영국 케임브리지, 세르비아 베오그라드, 인도 벵갈루루, 일본 도쿄에 있다.</p>

<p>2023년 5월, LG전자와의 협력을 발표했다. 협력해서 RISC-V, AI기반 Video Codec Chiplet을 만든다고 한다. LG의 TV나 미래의 automotive 제품, 그리고 tenstorrent의 data center 제품들에 들어갈 예정이라 한다.</p>

<p>Tenstorrent는 RISC-V, AI기반 processor 기술, LG는 비디오 코덱 기술을 제공한다고 보면 될 것 같다.</p>

<p>Tenstorrent 사이트, 제품에 대한 내용은 나중에 추가
PCI: Peripheral Component Interconnect bus
1992년, 인텔에서 컴퓨터 주변기기 연결을 위해 발표한 Bus 규격이다.</p>

<p>PCIe: PCI Express
PCI에도 기술적 한계가 있었기 때문에, 인텔의 주도 하에 인텔, 델, HP, IBM이 모여 2003년에 PCI의 후속 인터페이스인 PCIe를 발표한다.</p>

<p>PCI 슬롯에는 2가지 버전이 있다. 32비트 버전과 64비트 버전이다.
32bit PCI slot: 124pin, 85mm
64bit PCI slot: 188pin, 130mm</p>

<p>PCIe slot은 x1, x2, x4, x8, x12, x16, x32로 총 7가지 버전이 있다.
이때, 예를 들어 x4 PCIe slot이면 4레인 PCIe slot이라 부른다. (lane)</p>

<p>PCIe 표준에 x12, x32가 존재하긴 하지만 거의 사용되지 않는다.</p>

<p>16레인은 주로 그래픽카드에,
4레인이나 2레인은 주로 M.2 형태 PCIe SSD에,
1레인은 사운드카드, 랜카드, 그 외 나머지 용도들에 사용된다.</p>

<p>ISA: Industry Standard Architecture
PCI 등장 이전에는 1981년 IBM에서 만든 ISA라는 규격이 있었다.
8비트 규격과 16비트 규격이 있었는데, PCI 등장 후 사라지게 됐다.</p>

<p>사운드카드:
컴퓨터의 소리를 처리하거나 아날로그로 변환하여 재생하기 위한 장치다.
사운드카드로 들어오는 입력은 디지털신호니까, 사운드카드는 DSP + DAC를 확장 카드로 만들어놓은 장치다.
이 확장 카드를 메인보드의 ISA, PCI나 PCIe slot에 꽂는거다.</p>

<p>사운드카드는 1980년대에 처음 개발됐고, 90년대부터 2000년대 중반까지 많은 인기를 누렸다.
하지만 2000년대 후반부터 CPU의 성능이 크게 좋아지기 시작했고, 메인보드에 내장된 기본 사운드 칩셋 성능도 크게 향상되어 입지가 줄어들었다.</p>

<p>Chipset: 각종 IC를 하나로 모아놓은 것을 말한다.</p>

<p>그러면, 컴퓨터에 사운드카드를 안끼우면 컴퓨터가 소리를 낼 수 없었나?
그건 아니다. 기본적인 삑삑 소리는 낼 수 있었다.</p>

<p>80년대에 생산된 게임기나 가정용 컴퓨터는 8비트 소리를 낼 수 있었다.
PSG(Programmable Sound Generator)라는 사운드 칩이 내장되어 있었기 때문이다.</p>

<p>근데, 같은 80년대에 나온 IBM PC들은 8비트 소리를 못내고, 스피커에 5V전압 걸어서 삑삑소리밖에 낼 수가 없었다.</p>

<p>대신, IBM PC의 장점은 확장성이었다. 메인보드에 다른 장치를 끼워 소리를 재생할 수 있었다.</p>

<p>1987년에 AD LIB 사운드카드가 출시됐고, 1989년에는 Sound Blaster 사운드카드가 출시됐다.
Sound blaster는 DSP칩을 내장하고 있었기 때문에, CPU 자원을 거의 사용하지 않고 8비트 mono 디지털 음원을 재생할 수 있었다.</p>

<p>AD LIB 사운드카드는 복제돼서 많이 풀렸지만, 그래도 소리를 제대로 듣고 싶으면 Sound Blaster 사운드카드를 사야 했다.</p>

<p>1992년에는 16비트 디지털 음원을 지원하는 Sound blaster 16이 출시됐다. 이것으로, PC에서도 CD음원과 같은 음질로 소리를 들을 수 있게 되었다.</p>

<p>사운드카드는 개인용 컴퓨터가 보급되기 시작한 80년대에는 사치품 내지 경외의 대상이었다.
국내에서는 90년대 초반까지도 대부분 컴퓨터에 사운드카드가 없어 다들 삑삑거리는 소리만 냈다.</p>

<p>90년대는 DOS시대가 끝나고 윈도우 시대가 시작되는 시기였다.</p>

<p>1990년대 후반에는 MP3등 음원을 압축할 수 있는 format이 나오면서, PC에서 나오는 음향에 대한 관심이 높아졌다. 당연히, 소리 재생을 넘어 고음질을 추구하게 됐다.</p>

<p>2000년대 이후로는 스테레오 2채널에서 나아가 5.1채널, 7.1채널 등 다채널 오디오 시스템이 유행했다.
5.1채널에는 스피커가 총 6개다. 서브우퍼를 0.1로 쳐서 5.1채널이라 부른다.
이런 것들이 서라운드 음향 시스템이다.</p>

<p>그 후 컴퓨터가 계속 좋아지면서, 음악 감상 뿐 아니라 음악 편집, 믹싱, 프로듀싱까지 할 수 있게 되었다. 그에 맞춰 다양한 장비들이 출시됐고, 그 장비들을 컴퓨터에 제대로 연결할 수 있도록 광 출력이나 coaxial(동축) 출력을 지원하는 사운드카드들이 나왔다.</p>

<p>90년대 후반부터는 메인보드에 사운드 칩셋이 끼워져 나오기 시작했다.
하지만 AC’97(인텔이 1997년에 만든 규격) 코덱 규격을 쓰던 초기 내장 사운드 칩셋은 성능이 구데기였다.</p>

<p>내장 사운드 칩셋: CPU 연산능력에 의존하는 소프트웨어 방식
사운드 카드: 사운드카드 내에서 처리하는 하드웨어 방식</p>

<p>‘코덱’이란 표현을 쓰는 것도, 내장 사운드 칩셋은 소프트웨어 방식이라 그렇다.</p>

<p>근데 이때는 CPU가 펜티엄2, 펜티엄3 수준일 때라 오디오 처리에 상당한 연산 비중을 할애해야 했다. 게다가, 메인보드 단가 낮추려고 오디오 관련 부품, 회로도 싼걸 많이 써서 white noise 등 각종 잡음도 심했다.</p>

<p>그래서 내장 사운드 칩셋이 나온 후에도, 음악을 중시하던 사람들은 다들 사운드카드를 따로 사서 썼다. 국내 회사들도 사운드카드를 많이들 제작했고, 대표적으로 옥소리 사운드카드가 있었다.</p>

<p>초기 내장 사운드칩셋은 그렇게나 구데기였지만, 2004년에 인텔이 ‘인텔 HD 오디오’규격을 공개하면서 내장 사운드칩셋의 성능이 비약적으로 발전했다.</p>

<p>또한, 이때쯤부터 멀티코어 CPU가 많이 나오고, CPU 코어당 성능도 향상돼서 CPU로 오디오처리를 하는 것에 대한 부담이 많이 줄었다.
그래서 내장 사운드 칩셋의 음질도 향상됐고, 5.1/7.1채널까지 지원하게 되면서 중저가 사운드카드들이 설 자리가 없어지게 되었다.</p>

<p>초기 메인보드 사운드 칩셋 시장에서는 인텔, VIA, ESS, 리얼텍 등이 경쟁했지만, 리얼텍이 2000년대 중후반부터 시장을 독점하고 있다.</p>

<p>2010년 기준으로, 내장 사운드 칩셋들은 스펙상으로는 잡음이 거의 없어졌고, sampling도 192kHz까지 지원하는 경우도 많다.</p>

<p>예를 들어, ALC898은 고가형 사운드카드 수준으로 균일한 출력을 보여주는데다가, SNR도 -110dB를 넘어간다.
CD 표준인 16비트 정수의 이론상 SNR이 -96dB다. 즉, -110dB면 CD급 음질을 재현하고도 남는 성능이다.</p>

<p>하지만 이건 어디까지나 스펙상의 성능이라, 고가 메인보드에서나 나오는 성능이다.
중저가 메인보드에 꽂힌 내장 사운드 칩셋의 출력은 스펙에 적힌만큼의 SNR을 보여주지 못한다.</p>

<p>그리고 비싼 케이스들은 절연이 잘 되어있지만, 저가 케이스들 중에는 그렇지 못한 경우가 있다.
이 경우, 본체에 흐르는 전기가 내장 사운드 칩셋에 노이즈를 만든다.</p>

<p>4GHz의 벽:
반도체공정이 미세화되면서, CPU 내 트랜지스터 집적도가 올라가게 되었다.
그 결과, 트랜지스터 방열면적이 줄어들었다.</p>

<p>근데, 전력소모는 크기가 작아졌다고 해서 작아지는게 아니다!
즉, 공정이 미세화될수록 방열면적은 줄어드는데 전력소모는 그대로라서 열 방출이 어려워진다.</p>

<p>그리고, CPU가 발전할수록 clock 주파수와 소비 전력 모두 계속해서 올라갔다.
그래서, 이대로는 열 방출이 안돼서 CPU clock이 4GHz를 넘을 수 없다는게 4GHz의 벽이다.
그래도 2010년대 이후로는 4GHz 넘는 CPU들이 많이 나오고 있다.</p>

<p>TDP: Thermal Design Power
CPU나 GPU 스펙을 보면 TDP가 적혀있는데, TDP 값 이상의 열 방출이 가능한 냉각 수단을 같이 쓰라는 뜻이다. TDP의 단위는 [W]다.</p>

<p>CPU에 공급되는 전력의 총량을 Pdynamic이라 하면 *수식 설명</p>

<p>Dark Silicon:
이것도 공정 미세화 때문에 생기는 문제다.
CPU에 넣어줄 수 있는 전력에는 한계가 있는데, 트랜지스터가 너무 많아서 일부 트랜지스터는 전력을 공급받지 못하는 현상이다.
이렇게 전력을 공급받지 못하는 구역을 ‘Dark Silicon’이라 한다.</p>

<p>SDR: Software Defined Radio
무선통신에서 신호 modulation, demodulation 과정을 소프트웨어로 구현한거다.
SDR이 나오기 전에는 modulation, demodulation이 모두 회로를 통해 구현됐기 때문에, 뭔가 제어를 하는게 어려웠다. RLC값 조절해서 주파수 좀 조절하는 정도였다.</p>

<p>그래서 한가지 기기로 다양한 통신 방식을 쓰거나, 넓은 주파수 대역을 사용하기가 어려웠다.
그래서 회로를 다중으로 구성하니 어쩌니 하면서 구조가 많이 복잡해졌다.</p>

<p>그러다가 디지털 modulation/demodulation 기술이 발전해서 DSP와 FPGA로 RF신호를 처리할 수 있게 되었다. 이렇게, 백엔드의 RF 신호처리 회로를 FPGA나 DSP로 대체한 것이 SDR이다.</p>

<p>모뎀(MODEM): MOdulator and DEModulator
통신을 위한 modulation/demodulation 장비다. 이때 modulation/demodulation은 디지털로 하기 때문에, 모뎀 자체에 ADC, DAC가 달려있는 경우도 있다.</p>

<p>90년대에는 전화망을 그대로 사용해 통신망을 이용하는 전화 접속 모뎀(Dial-up MODEM)이 많이 쓰였다.</p>

<p>현재는 통신 장치들이 모두 모뎀을 갖고 있다.
인터넷 연결에도 모뎀이 쓰이고, 핸드폰의 2G, 3G, 4G, 5G, WiFi 통신칩도 모뎀 기능이 있다.</p>

<p>OSI 7계층 데이터 통신 모델에서, layer1과 layer2가 보통 통합 모뎀 칩 형태로 구현된다.</p>

<p>Layer 1 : physical layer.
유선통신이면 케이블 접점, 무선통신이면 무선 RF소자</p>

<p>Layer 2 : MAC layer (Medium Access Control)
MUX, DEMUX, ADC, DAC가 있는 곳이다. ASIC, FPGA같은 디지털 논리회로로 만들어져 있다.
Slotted Aloha, CSMA같은 트래픽 제어도 여기서 한다.</p>

<p>Layer 2의 데이터는 ‘패킷’이라 불린다.</p>

<p>전화 접속 모뎀은 컴퓨터의 디지털 신호를 아날로그 음성신호로 바꿔 전화선에 태워 보낸다.
그리고 전화선을 통해 전달받은 아날로그 음성 신호는 다시 디지털 신호로 바꿔 받는다.</p>

<p>옛날에 전화 접속 모뎀도 없었을 때는 음향 커플러(Acoustic Coupler)라는 것을 사용했다.
모뎀은 전화선 케이블을 모뎀에 직접 꽂지만, 커플러는 수화기를 커플러 위에 올려넣고 스피커에서 나오는 소리를 전화로 송신하는 방식이었다.</p>

<p>CD: Compact Disc
1979년에 소니와 필립스가 공동 개발해서, 1982년에 상용화됐다.
780nm 적외선으로 데이터를 읽는 광학 저장매체고, 약 700MB 정도를 담을 수 있다.</p>

<p>DVD: Digital Versatile Disc
1996년에 CD의 후속 광학 저장매체로 등장했다.
소니, 도시바, 파나소닉, 필립스가 공동개발했다.
2000년 3월에 나온 플레이스테이션2가 DVD 재생기능을 포인트로 내세우고 발매되면서 DVD가 널리 보급됐다.</p>

<p>근데, 2000년대에는 불법 다운로드가 성행해서 DVD시장이 커지지 못했고,
2010년대부터는 스마트폰, OTT가 등장해서 DVD가 사라졌다.</p>

<p>DVD는 650nm 빨간 빛으로 데이터를 읽는 광학 저장매체고, 싱글레이어면 4.7GB, 듀얼레이어면 8.5GB를 저장할 수 있다.</p>

<p>Blu-ray:
405nm 보라색 빛으로 데이터를 읽는 광학 저장매체다.
2003년에 소니에서 나왔다.</p>

<p>싱글레이어: 25GB, 33GB
듀얼레이어: 50GB, 66GB
트리플레이어: 75GB, 100GB
쿼드레이어: 128GB</p>

<p>블루레이 이후에는 더 용량이 큰 AD(Archival Disc), HVD(Holographical Versatile Disc)가 나올 수 있다고 한다.</p>

<p>작년에 들었던 강연 내용:</p>

<p>백주년기념관 세션</p>

<p>설명해주신 분은 파운드리 사업부 최시영 사장님</p>

<p>주된 내용은 반도체의 중요성, 삼성전자 파운드리가 나아가려는 방향이었다.</p>

<p>그러나 그닥 중요한 내용은 없는 듯 하다.</p>

<p>3줄요약:
1. 코로나4차산업혁명미중패권경쟁시대에 중요한 것은 반도체다.
2. 그래서 반도체 찍어내는 파운드리가 아주 중요하다.
3. 여기에는 다양한 분야 사람들이 필요하니 많이들 지원해라.</p>

<p>=========================================</p>

<p>4차 산업혁명 시대에는 데이터가 서로 소통해서 새로운 가치가 창출되는데, 이런거 하려면 반도체가 필요하다.</p>

<p>또, 코로나때문에 비대면 작업 필요성과 관련된 신기술들이 생겼고,
그거때문에도 반도체 수요가 올랐다.</p>

<p>반도체로 뭘 하길래 저런거 할때 반도체가 필요한가?</p>

<p>반도체가 하는 일:
Memory : 낸드플래시, ssd, ram 등
Dicision making : cpu 등
Perception+Manipulation : 이건 놓쳤음</p>

<p>이렇게, 반도체로는 메모리만 하는게 아니다.
반도체에는 메모리 반도체랑 시스템 반도체가 있고, 2022년 반도체 시장은 시스템 반도체가 70%, 메모리 반도체가 30%였다.</p>

<p>요즘 이야기 많이 나오는 시스템 반도체로는 차량용 반도체가 있다. 차량용 반도체는 중요하다. 사고나면 뒤지니까.</p>

<p>하여간 이래서 반도체 수요가 올랐으니 반도체 공급을 해야 하는데, 반도체 생산 시설(서플라이 체인)은 하루이틀만에 만들 수 있는게 아니다.</p>

<p>그래서 요즘 맨날 반도체 부족하다는 소리가 나오는거고, 세계 여러 나라들이 국가 안보를 위해 원활한 반도체 수급을 강조하고 있다.</p>

<p>그렇기 때문에, 반도체를 찍어내는 파운드리는 아주아주 중요하다.</p>

<p>그러나, 세상에 수많은 반도체 회사들이 있지만 대부분이 팹리스 회사들이다. 직접 나노공정을 하는건 아주 힘든 일이기 때문이다.</p>

<ul>
  <li>팹리스: 파운드리는 없고, 설계도만 그려서 생산은 외주맡기는 회사들</li>
</ul>

<p>파운드리가 있는 회사들 중에서도, 10나노 이하 공정이 가능한 회사는 전세계에 tsmc와 삼성전자 뿐이다.</p>

<p>인텔도 파운드리가 있긴 하고, 최근 크게 투자하려고는 한다지만 기술 격차를 따라오기는 어려울 것이다.</p>

<p>그렇다고 파운드리가 설계도 들고 오면 그냥 그거대로 찍어내는것만하는 곳인가? 그건 아니다.</p>

<p>대부분의 팹리스 회사들은 설계도를 100% 그려올 능력이 없다. 그냥 여기는 잘 모르겠으니까 대충 이렇게 해주세요 하면 파운드리 회사에서 빈칸을 채워주기 때문에, 파운드리도 자기들이 뭘 만들고 어떻게 작동하게 되는지 알아야 한다.</p>

<p>찍어내는것도 단순히 꽝꽝 찍어내는게 아니다. 낸드플래시 메모리는 DRAM보다 스케일링(소형화)이 어려워서 3차원으로 몇백층을 쌓아 만든다.</p>

<p>그리고 나노공정도 계속해서 발전한다. 삼성전자 파운드리가 처음으로 세계에 이름을 알린 것은 14나노 FinFET이었고, 올해 상반기에는 세계 최초로 3나노 공정을 시작했다.</p>

<p>*tsmc는 하반기부터 한다고 한다.</p>

<p>그래서 이런저런 연구를 많이 해야 하기 때문에, 전기전자가 아니어도 다양한 분야 사람들이 필요하다. DS에는 소프트웨어 개발자만 해도 만명이 있다.</p>

<p>그니까 여러분 많이많이 지원해주세요.</p>

<p>=========================================</p>

<p>내 질문:
요즘은 3나노 공정까지 가능하다고 말씀해주셨는데, 무한정 간격을 줄이면 전자가 다 통과해버리는 문제가 발생하기 때문에 나노 공정에는 태생적 한계가 있다고 들었다. 삼성전자에서는 이 문제를 어떻게 해결하려고 하는지 여쭤보고 싶다. 그럼에도 계속 작게 만드는 것을 목표로 하는지, 아니면 아예 새로운 기술을 도입해서 그 문제를 해결하는지 궁금하다.</p>

<p>사장님 대답:
그건.. 교수님한테 물어보세요. *실제로 한 말</p>

<p>나노공정을 통한 스케일링(소형화)도 중요하지만,
반도체 회로의 전력 소모를 줄이는 것도 아주 중요하다.
그래서 단순히 소형화만을 목표로 공정을 발전시키지는 않는다.</p>

<p>그리고, 그런 문제때문에 회사 상부에서 몇나노 아래로는 하지 마라!라고 하지는 않는다. 연구하는 사람들 괜히 괴롭히는거 아니겠는가.</p>

<p>또한, 패키징을 통해 공정 문제를 개선하는 경우도 많다.
설계도를 보면 어떤 부분들은 3나노 공정이 필요하지만,
또 어떤 부분들은 10나노 공정만 해도 충분하다.</p>

<p>그래서 3나노 회로와 10나노 회로 연결부분을 잘 만들어서 그런 문제를 해결하기도 한다.</p>

<p>*3나노 10나노 연결을 ‘heterogenous한 integration’이라고 표현하셨는데, 이게 실제로 여기서 쓰는 표현인지 아니면 그냥 한국말 안떠올라서 저렇게 표현한건지는 모르겠다.</p>

<p>다른 사람들 질문:
미국에 투자한다 하셨는데 한국에도 투자하나?
-&gt; 합니다.
나는 기계과 박사 유체전공인데 나도 거기서 할 수 있는게 있나?
-&gt; 있습니다.</p>

<p>=========================================</p>

<p>내 생각:
별로 할 말은 없다. 오프닝 세션답게 파운드리를 소개하고 그 중요성을 강조했다</p>

<p>첫번째 강연</p>

<p>설명해주신 분은 S.LSI 사업부, SoC Platform개발팀의 허운행 부사장님</p>

<p>*삼성전자 체계는 사업부-팀-그룹-파트인 것으로 알고 있다.</p>

<p>여기서 하는 일은 엑시노스에서 굴릴 프로그램을 만드는 일이다.</p>

<p>3줄요약:
1. 하드웨어 발전보다 딥러닝 모델 발전이 더 빠르다.
2. 그래서 딥러닝 모델을 엑시노스에 집어넣는 일을 한다.
3. 생각보다 자율주행 소프트웨어 개발에도 관심이 많다.</p>

<p>=========================================</p>

<p>S.LSI 사업부는 엑시노스 만드는 곳이다.
근데 엑시노스 하드웨어만 만드는건 아니고, 엑시노스에서 돌아갈 소프트웨어도 다 여기서 만든다.</p>

<p>그 소프트웨어를 만드는 곳이 SoC Platform 개발팀이다.</p>

<p>*컴퓨터에는 cpu가 있듯이, 핸드폰에는 SoC가 있다.
퀄컴 스냅드래곤, 애플 M1, 삼성 엑시노스 등이 다 SoC다.
cpu = central processing unit
SoC = System on Chip</p>

<p>그러면 뭐 어떤 소프트웨어를 엑시노스에서 돌려야 하는가?</p>

<p>옛날에는 SoC 발전 속도가 그냥 무어의 법칙을 따라갔다.
하지만 CV, NLP 모델의 발전 속도가 무어의 법칙보다 빠르고,
Transformer 모델의 발전 속도는 그거보다 더 빠르다.</p>

<p>그래서 저렇게 훌륭한 머신러닝 모델들을 SoC에서 사용할 수 있게  해주는 소프트웨어를 만드는게 이 팀에서 주로 하는 일이다.
이렇게 하면 무어의 법칙보다 빠르게 발전할 수 있으니까.</p>

<p>생각보다 쉬운 일은 아니라고 한다. 새로 개발되는 머신러닝 모델들은 그래픽카드 수십개 꽂아서 만든건데, 그게 엑시노스 칩 하나에서 돌아가게 하려면 많은 연구가 필요하다.</p>

<p>안타까운 이야기지만, 머신러닝은 계속 새로운 모델들이 나오기 때문에 회사 와서도 계속 공부해야 한다.</p>

<p>참고로, 이렇게 머신러닝 기술을 도입한 프로세서를 삼성전자는 NPU라고 부르고, 구글은 TPU라고 부른다.</p>

<p>회사에서 소프트웨어를 만들 때는 어떻게 만드는가?
일단은 open source 코딩 자원으로 구현하고자 하는 머신러닝 모델을 일단 만들어본다. C, C++을 주로 사용한다고 한다.</p>

<p>그 다음에는 마찬가지로 open source로 되어있는 모바일용 머신러닝 SDK에 그 모델을 만들어보고,</p>

<p>TRex라는 삼성전자 내부 framework를 통해 최종적으로 만들어낸다.</p>

<p>이런 식으로 구현된 머신러닝 모델을 삼성전자 서버실에 쌓아둔 데이터로 몇년간 학습을 시킨다. 학습이 끝나면 제품이 나오게 된다.</p>

<p>학습을 돌릴 때는 security가 상당히 중요하다.
Security가 부족하면 학습이 이상하게 돼서 제대로 작동을 안한다.</p>

<p>하여간 이렇게 발전시킨 제품으로 온갖 AR,VR,XR,MR,메타버스 등을 개선하려고 한다. 빅스비, 지문 인식, 카메라 성능도 개선한다.</p>

<p>제품 출시 전에 게임 회사들이랑 연락해서 그 게임이 신제품에서 잘 굴러갈지 검토하기도 한다.</p>

<p>=========================================</p>

<p>옛날 애니콜 만들던 시절에는 SoC용 코드가 30만줄 정도 됐다고 한다.</p>

<p>그러다가 안드로이드 기반 스마트폰을 만들게 됐는데, 초창기에는 구글에서 만들어놓은 OS를 삼성전자에서 감히 건드리지 못해 하드웨어만 하던 시절이 있었다. 그게 한 10년 전이니, 10년만에 여기까지 발전했다.</p>

<p>2030년쯤에는 삼성전자에서 만든 XR OS가 나올 것이다.
원래는 이걸 페이스북에서 먼저 하려고 했는데, 회사가 영 좋지 않은상황이 되어 아마 삼성전자가 먼저 할 것 같다.</p>

<p>*구글에 ‘XR OS’만 치면 무슨 골프채밖에 안나오고, ‘XR OS Meta’라고 검색해야 관련 정보가 나온다.</p>

<p>앞으로 이 팀은 핸드폰 SoC용 소프트웨어 뿐 아니라 웨어러블 기기와 자율주행 자동차를 위한 소프트웨어도 만들고자 한다.</p>

<p>테슬라는 지들이 차도 만들고 자율주행 소프트웨어도 만들지만, 다른 자동차 회사들은 그럴 수 없기 때문에 기존 자동차 회사들과 협업을 논의한다.</p>

<p>모바일에도 그랬듯이, 자동차에도 ARM 기반 프로세서를 넣으려고 한다.</p>

<p>차이점이라면 자동차용 프로세서는 모바일의 10배는 되는 성능이 필요하며, 머신러닝 잘못 돌리면 바로 대형사고로 이어질 수 있기 때문에 모델 학습시 높은 security가 필요하다는 점이다.</p>

<p>=========================================</p>

<p>내 질문:
소프트웨어 개발시에 C, C++을 주로 쓴다고 하셨는데, 혹시 SoC 하드웨어 만들때 쓰이는 Verilog같은 언어도 필요합니까?</p>

<p>부사장님 대답:
필요 없다.</p>

<p>사업부 내에 ‘시스템 엔지니어’들이 있는데, 이 사람들이 어떤 기능은 소프트웨어로 구현하고 어떤 기능은 하드웨어로 구현할지 다 정해준다. 그래서 그냥 구현하라는 기능만 열심히 모델 만들어서 구현하면 된다.</p>

<p>그리고 항상 C,C++만 쓰는건 아니다. C,C++은 라이브러리가 좋아서 쓰는거긴 한데 flexibility가 좀 떨어진다는 단점이 있다.</p>

<p>그래서 장단점 따져서 다양한 언어들로 개발을 하게 된다.
예를 들어, security가 중요한 경우에는 Rust, java를 쓴다.</p>

<p>=========================================</p>

<p>내 생각:
엑시노스용 소프트웨어라길래 OS만드는 곳인가 했는데, 그거 말고도 다양한 프로그램들을 만드는 듯 하다. 좋은 곳 같다.</p>

<p>그리고 이 사람들 생각보다 자율주행에 관심이 많은 것 같다.
애플이 애플카 만들려고 난리치던게 떠올랐는데, 자율주행이 정말 유망한 분야라서 다들 투자하는건지 아니면 그냥 애플이 하니까 삼성도 하는건지는 모르겠다.</p>

<p>두번째 강연</p>

<p>설명해주신 분은 혁신센터, IT인프라그룹의 진인식 상무님</p>

<p>여기서 하는 일은 수율 개선이다.</p>

<p>3줄요약:
1. 웨이퍼에 반도체 그리는 일은 2달이나 걸린다.
2. 그래서 중간에 생긴 오류 못찾으면 2달을 통째로 날린다.
3. 그래서 오류를 방지하고 찾는게 이 사람들 일이다.</p>

<p>=========================================</p>

<p>전세계 어느 반도체 파운드리든, ASML이라는 네덜란드 촌구석 회사에서 만든 EUV 장비라는걸 사용한다.
요즘 쓰이는 EUV 장비는 하나에 3천억 정도 하고,
차기 장비는 5천억 정도 할 예정이라고 한다.</p>

<p>그런데, 하이닉스도 EUV 장비를 쓰고 삼성전자도 EUV 장비를 쓰는데 수율은 삼성전자가 더 좋다. 결국 같은 장비를 어떻게 운용하는지가 곧 기술이다.</p>

<p>예를 들어 인텔과 tsmc의 fab은 단층 fab이지만
삼성전자의 fab은 크고 아름다운 복층이다.
이런 식으로 다들 조금씩 다르다.
삼성전자는 이 복층 fab에서, 지난달부터 tsmc보다 빠르게 3나노 공정 양산을 시작했다.</p>

<p>*fab = fabrication facility</p>

<p>IT인프라그룹이 이런거 하는거다. 생산 라인을 어떻게 관리할지, 장비를 어떻게 운용할지, 불량품은 어떻게 찾을지 이런거 한다.</p>

<p>삼성전자에서는 이런 업무들을 APC, FDC 2가지로 분류한다.</p>

<p>1. APC : Advanced Process Control</p>

<p>같은 장비를 사용해서 같은 회로를 그려도,
장비 제어 기술이 딸리면 시간이 더 오래 걸린다.
그래서 어떤 회사는 하루에 웨이퍼 5천장 찍어내는데 어떤 회사는 5백장 찍어내는거다.</p>

<p>게다가 제어 기술 요구 수준이 상당히 높아서 연구가 많이 필요하다.
웨이퍼가 한반도라면 오차 허용 영역은 500원짜리 동전 정도다.</p>

<p>낸드플래시 메모리 만드는 경우에도, 층 하나 쌓으려면 파라미터 몇천개를 제어해야 한다고 한다. 근데 이걸 수백층 쌓아야 한다.</p>

<p>이 복잡한 행동을 하기 위해서는 당연히 공정 모델링을 잘 해야 한다.</p>

<p>미분방정식으로 모델링하기도 하지만,
그렇게 하면 너무 복잡해져서 보통 선형대수에서 배운 linearization이나 인공지능을 써서 모델링한다고 한다.</p>

<p>이렇게 모델링이 끝나면 Digital twin concept로 먼저 시뮬레이션을 해보고 제어를 시작한다.</p>

<p>*digital twin = 프로그램으로 현실이랑 똑같은 상황 만들어놓고 시뮬레이션 해보는 것</p>

<p>제어 알고리즘의 예시로 F-14와 F-35를 언급하셨다.</p>

<p>F-14는 탑건1,2에 나오듯 파일럿이 페달밟고 손잡이 올리고 이것저것 해야 3차원 기동이 되는데,</p>

<p>F-35는 그동안 파일럿들이 해온 온갖 페달, 손잡이 조작들을 알고리즘화 해서 편하고 부드럽게 3차원 기동이 가능하게 한다.</p>

<p>2. FDC : Fault Detection and Classification</p>

<p>반도체 공정 하면 다들 8대공정을 떠올리고, 틀린 말은 아니지만 실제로 행해지는 step들은 1000개쯤 된다.</p>

<p>이 step 하나마다 파라미터 몇천개를 제어해줘야 하기 때문에,
깨끗한 웨이퍼 하나를 넣어서 거기에 반도체가 다 그려지기까지는 2달정도가 걸린다.</p>

<p>즉, 2달동안 웨이퍼에 그림그렸는데 확인해보니 잘못그려졌으면 2달 날리는거다.</p>

<p>이런 끔찍한 일을 방지하려면 중간중간 에러가 발생했는지 확인해줘야 한다. 예를 들어 10일차에 에러를 확인하면 나머지 50일은 날리지 않을 수 있다.</p>

<p>근데 중간에 에러 찾는게 생각만큼 쉬운 일이 아니다.
완성품을 보면 제대로 됐는지 망했는지 바로 알 수 있지만,
중간에 봐서는 이게 맞는지 아닌지 확인하기 어렵다고 한다.</p>

<p>그래서, 중간중간 웨이퍼 사진을 찍어서 그 이미지들로 머신러닝을 한다. 그렇게 학습된 모델로 에러를 찾아낸다.</p>

<p>물론 이 방법도 문제가 있다. 반도체 생산라인 하나당 하루에 10테라바이트씩 데이터가 쌓여서 감당이 안된다.</p>

<p>그렇기에 여러가지 다양한 방법으로 에러를 사전에 포착하려 한다.</p>

<p>따라서 여러분같이 다양한 백그라운드를 가진 인재들이 필요하다.</p>

<p>우리 사람 많이 뽑을겁니다. 쓰시기만 하면 다 붙여드리겠습니다!!</p>

<p>=========================================</p>

<p>내 질문:
사람들 전공이 어떻게 됩니까?</p>

<p>상무님 대답:
나는 화공이고, 수학과 기계과 등 다양하다.</p>

<p>다른 사람들 질문:
뭘 잘하면 됩니까?
-&gt;CS, Physics를 잘하시면 된다.
TCAD 쓰는 부서도 있나요?
-&gt;있다. 웨이퍼 모델링, FEM 기반 시뮬레이션 등 다 거기서 한다.
이것저것 하는 일이 많은 곳이니 뭐하던 분들이든 환영한다.</p>

<p>=========================================</p>

<p>내 생각:
산업공학과만 있을 것 같아서 질문했는데, 생각보다 다양한 과가 있는 듯 하다.</p>

<p>하지만 결국 하는 일이 생산라인 모델링이라, 전기전자보단 다른 과에 어울리는 곳이 아닌가 싶다. 그래도 좋은 곳 같다.</p>

	</div>
</article>
		</div>
	</div>
  </body>
</html>